<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构笔记(一)：算法复杂度（基础篇）</title>
      <link href="/2023/08/15/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC(%E5%9F%BA%E7%A1%80%E7%AF%87)/"/>
      <url>/2023/08/15/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC(%E5%9F%BA%E7%A1%80%E7%AF%87)/</url>
      
        <content type="html"><![CDATA[<h2><span id="suan-fa-fu-za-du-fen-xi-jian-yao-gai-gua">算法复杂度分析简要概括</span><a href="#suan-fa-fu-za-du-fen-xi-jian-yao-gai-gua" class="header-anchor">#</a></h2><p><strong>算法复杂度</strong></p><ul><li><strong>时间复杂度</strong></li><li><strong>空间复杂度</strong></li></ul><hr><blockquote><p>时间复杂度的简单理解：进行算法分析时，我们假设每行的每次执行时间是t，n是某个循环的中止值。随后我们统计下所有行的代码执行次数，记作f(n)，那么我们整个的程序的总的执行时间T为:f(n)×t。根据T函数我们可以看出T与f(n)成正比。此时我们就可以根据f(n)的函数增长率去估算时间复杂度，<strong>这里我们需要注意的是,我们只关注函数的增长率，而不关注n究竟是多大。</strong></p></blockquote><h2><span id="tui-dao-fang-fa-jie-shao">推导方法介绍</span><a href="#tui-dao-fang-fa-jie-shao" class="header-anchor">#</a></h2><h3><span id="tui-dao-liu-cheng">推导流程</span><a href="#tui-dao-liu-cheng" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><p><strong>核心：只关注推导出来的函数的最高阶项的阶数</strong></p><h3><span id="ju-ge-li-zi">举个栗子</span><a href="#ju-ge-li-zi" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行1次</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//执行n+1次</span><span class="token punctuation">{</span> count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行n次</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>根据注释可推出总次数的函数式f(n)=1+n+1+n=2n+2</p></blockquote><p><strong>化简原则:</strong></p><ul><li><strong>①函数如果是一个常数，不管多大，全用1代替，记作O(1)</strong></li><li><strong>②函数只保留最高阶项，若最高阶项的系数是常数，则统一用1代替，否则保留系数</strong></li></ul><blockquote><p>本题根据化简原则②可以将f(n)=2n+2，记作f(n)=n,即O(n),这就是我们这段程序的时间复杂度</p></blockquote><h3><span id="yi-wen">疑问</span><a href="#yi-wen" class="header-anchor">#</a></h3><blockquote><p>Q1:刚学的时候，关于这道例子我是有一个问题的，那就是n明明在一开始的时候就定义了n=100。那n不应该是一个常数吗？我的函数式不应该写成1+100+1+100=202吗？时间复杂度应该是O(1)而不是O(n)呀</p></blockquote><hr><blockquote><p>A1：我认为时间复杂度的理解应该是基于过程而言的，而不是基于结果的。基于结果，整个n肯定是一个有结果的值，我们可以看作它是一个基于常数时间复杂度的算法。但是当我们谈论时间复杂度时，我们通常会假设 n 是一个变量，它可以取任意值。这样我们就可以分析算法的运行时间随着输入数据规模的增长而增长的速度。</p><p>回到上面的问题，f(n)=2n+2,我们说n=100的时候，我们从结果的角度看，的确它可以叫做O(1)的时间复杂度，但是n是可以变化的，n可以是1，2，3……10000等等。也就是说我们是不只研究单单n=100这一个例子。我们研究的是一整个关于f(n)函数的增长变化情况的全局，本题的例子中这个f(n)的变化明显是类似于线性的变化，于是我们根据化简原则，可以得出时间复杂度是O(n),而不是O(1)<br><img src="https://img1.imgtp.com/2023/08/16/2LRqrNWv.png" alt="img"></p></blockquote><h3><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h3><blockquote><p><strong>算法的复杂度是基于过程的而非单一的结果,根据循环的规律去写出次数对应的函数是关键，因为我们研究的是函数的变化速率的方向。最后，根据化简原则，我们将函数化简之后得到的表达式就是我们需要的时间复杂度O()</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start: 列出各行代码的执行次数op=&gt;operation: 统计总次数并且写成函数式子op1=&gt;operation: 对函数式子进行化简处理e=&gt;end: 分析结果st-&gt;op-&gt;op1-&gt;e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2023/08/14/%E5%89%8D%E8%A8%80/"/>
      <url>/2023/08/14/%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>说实话，这是我第一次想着搭建一个个人博客来创作，事情的起因是前天学校老师给了我一套蓝桥杯的算法资料，那套资料对于算法的分类写的非常清晰，一目了然。于是我当时二话不说就写了一下午。不得不说，如果算法如果不难的话还是很有趣的<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。哈哈哈。那种感觉就像成功就在你眼前，但是你一抓他就往前跑。不断刺激你去抓到他。这种感觉是又爱又恨。那天写了几节之后，我开始问我自己，学习这些算法，如果我只是单单的像流水线一样过了一遍，真的有效吗？有过之前经历过无数次现实毒打的经历的经验之后，我明确告诉我自己，这是不可能的，学习的本质应该是不断的重复，以来对抗遗忘。所以顺其自然的我就想着搭建一个个人博客，来主要作为记录我个人的笔记平台，用来总结我写过的每一道算法题，以及背后对原理的思考。</p><p>比起传统的纸质笔记本，我认为电子化笔记的可以不受地点和时间的制约，这是我选择它的一大原因。同时呢，如果有能力的话，我也想分享高中的信息技术的内容。因为曾经我最迷茫的时候，是很多拥有公众号的技术老师以及博主分享了很多珍贵的资料，让我在黑暗中能够看见光亮。高中信息技术这门课改革之后加入了python以及数据结构。难度直线飙升，这对本就缺少资源的普通高中的学生更是雪上加霜。我深深的体会过这一点，所以我也想分享这些内容，发一点光，帮助曾经像我一样迷茫的同学们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
