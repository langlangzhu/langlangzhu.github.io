<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++sort()排序应用</title>
      <link href="/2023/09/16/C++%20sort()%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8/"/>
      <url>/2023/09/16/C++%20sort()%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>#C++ sort()排序</p><p>##例题一：<br>题目描述</p><blockquote><p>某涉密单位下发了某种票据，并要在年终全部收回。每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。你的任务是通过编程，找出断号的ID和重号的ID。假设断号不可能发生在最大和最小号。</p><blockquote><p>输入格式<br>第一行包含整数 N，表示后面共有 N 行数据。接下来 N 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。</p></blockquote></blockquote><blockquote><blockquote><p>输出格式<br>要求程序输出1行，含两个整数 m,n，用空格分隔。其中，m表示断号ID，n表示重号ID。</p></blockquote></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ID<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//输出的时候在输入完数据之后要按Ctrl+Z，然后回车，就可以输出结果了</span>        ID<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>ID<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ID<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化m为一个无效值</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化n为一个无效值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ID<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ID<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> ID<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            m <span class="token operator">=</span> ID<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ID<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> ID<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> ID<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>##例题二：<br>题目描述</p><blockquote><p>某次科研调查时得到了几个自然数，每个数均不超过1.5&lt;10^9。已知不相同的数不超过10^4个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。</p></blockquote><blockquote><p>输入描述<br>第1行是整数，表示自然数的个数。第2~n+1行每行一个自然数。其中1≤n≤2×10^5，每个数均不超过1.5≤10^9</p><p>输出描述<br>输出m行(m为n个自然数中不相同数的个数)，按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>vector <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> number<span class="token punctuation">;</span><span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cin<span class="token operator">>></span>n<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cin<span class="token operator">>></span>temp<span class="token punctuation">;</span>  number<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">sort</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>number<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>   c<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>number<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>number<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//当下一个数不和当前数相等时说明重复数结束</span>         <span class="token punctuation">{</span>           cout<span class="token operator">&lt;&lt;</span>number<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>           c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="li-ti-san">例题三</span><a href="#li-ti-san" class="header-anchor">#</a></h2><blockquote><p>设有几个正整数a1..a_n,将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。<br>输入描述<br>第一行有一个整数，表示数字个数n。第二行有n个整数，表示给出的n个整数a_i.其中，1≤n≤20,1≤a_i≤10^9。<br>输出描述<br>输出一个正整数，表示最大的整数</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>string temp<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> number<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>string a<span class="token punctuation">,</span>string b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">></span>b<span class="token operator">+</span>a<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//如果前面的大，则第一个参数在第二个参数之前，实现了降序排序</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> cin<span class="token operator">>></span>temp<span class="token punctuation">;</span>        number<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>number<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i<span class="token operator">:</span>number<span class="token punctuation">)</span>   <span class="token punctuation">{</span>       cout<span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span>   <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过这题我想来介绍一下c++里面的sort（）函数的细节。<br>首先sort（）里面一般有三个参数，第一个是排序的起点，第二个则是终点，这两个参数类型都必须是迭代器。第三个参数是比较参数，决定排序的方式。<br>这里c++官方技术文档是这样定义的：<br><strong>第一个和第二个参数：随机访问要排序的序列的初始位置和最终位置的迭代器。使用的范围为，包含first和last[first,last)之间的所有元素，包括first指向的元素但不包括last指向的元素。随机访问迭代器应指向一个类型交换已正确定义，并且既可移动构造又可移动分配。</strong><br><strong>第三个参数： 接受范围内的两个元素作为参数并返回可转换为 的值的二元函数bool。返回的值指示作为第一个参数传递的元素是否被视为在它定义的特定严格弱排序中位于第二个参数之前。该函数不得修改其任何参数。这可以是函数指针或函数对象。</strong></p><blockquote><p>这里不用管严格弱排序的意思，这句话换句话的意思就是说，如果返回值是True，则第一个参数将会在第二个参数前面，返回值是True则反之。<br>拿本题的例子来说：</p></blockquote></blockquote><blockquote><pre><code>           bool cmp(string a,string b)          {                if(a+b&gt;b+a)   //如果前面参数1大，则第一个参数会第二个参数之前，总体上来看就是大的会在小的前面，这就相当于实现了降序排序。                  return true;                else                  return false;                } //这里的a就代表了参数1，这里的b就代表了参数2.</code></pre></blockquote><p>第三个参数可以自己写，也可以调用系统自带的：</p><blockquote></blockquote><h2><span id="jie-gou-ti-pai-xu">结构体排序</span><a href="#jie-gou-ti-pai-xu" class="header-anchor">#</a></h2><h3><span id="li-ti-yi"><strong>例题一</strong></span><a href="#li-ti-yi" class="header-anchor">#</a></h3><blockquote><p>某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 5 名学生发奖学金。期末，每个学生都有 3 门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，<strong>如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，</strong>这样，每个学生的排序是唯一确定的。<br>任务：先根据输入的 3 门课的成绩计算总分，然后按上述规则排序，<strong>最后按排名顺序输出前 5 名学生的学号和总分</strong>。注意，在前 5 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分）是：</p><pre><code>          7 279        5 279</code></pre><p>这两行数据的含义是：总分最高的两个同学的学号依次是 7 号、5 号。这两名同学的总分都是 279 （总分等于输入的语文、数学、英语三科成绩之和），但学号为 7 的学生语文成绩更高一些。如果你的前两名的输出数据是：</p><pre><code>            5 279          7 279</code></pre><p>   则按输出错误处理，不能得分。<br>   输入描述<br>   第1行为一个正整数n(6≤n≤300)，表示该校参加评选的学生人数。第2到n+1行，每行有3个用空格隔开的数字，每个数字都在0到100之间。第j行的3个数字依次表示学号为j-1的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为1~n(恰好是输入数据的行号减1)。所给的数据都是正确的，不必检验。<br>   输出描述<br>   输出共有5行，每行是两个用空格隔开的正整数，依次表示前5名学生的学号和总分。</p></blockquote><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> score<span class="token punctuation">{</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>  <span class="token keyword">int</span> chinese<span class="token punctuation">;</span>  <span class="token keyword">int</span> math<span class="token punctuation">;</span>  <span class="token keyword">int</span> english<span class="token punctuation">;</span>  <span class="token keyword">int</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span>s<span class="token punctuation">[</span><span class="token number">305</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">struct</span> score a<span class="token punctuation">,</span><span class="token keyword">struct</span> score b<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>sum<span class="token operator">==</span>b<span class="token punctuation">.</span>sum<span class="token punctuation">)</span>    <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>chinese<span class="token operator">==</span>b<span class="token punctuation">.</span>chinese<span class="token punctuation">)</span>        <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>index<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>index<span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>chinese<span class="token operator">></span>b<span class="token punctuation">.</span>chinese<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>         <span class="token keyword">else</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>sum<span class="token operator">></span>b<span class="token punctuation">.</span>sum<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">;</span> cin<span class="token operator">>></span>n<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token operator">=</span>j<span class="token punctuation">;</span>   cin<span class="token operator">>></span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>chinese<span class="token operator">>></span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>math<span class="token operator">>></span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>english<span class="token punctuation">;</span>   s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token operator">=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>chinese<span class="token operator">+</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>math<span class="token operator">+</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>english<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>s<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="li-ti-er">例题二</span><a href="#li-ti-er" class="header-anchor">#</a></h3><blockquote><p>外卖店优先级<br>题目描述<br>“饱了么”外卖系统中维护着 N 家外卖店，编号 1 ∼ N。每家外卖店都有 一个优先级，初始时 (0 时刻) 优先级都为 0。每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减 到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果 优先级小于等于 3，则会被清除出优先缓存。给定 T 时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优 先缓存中?<br>输入描述<br>第一行包含 3 个整数 N,M,T。以下 M 行每行包含两个整数 ts,id，表示 ts 时刻编号 id 的外卖店收到一个订单。其中，1≤N,M,T≤10^5 ,1≤ts≤T，1≤id≤N。<br>输出描述<br>输出一个整数代表答案。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span>  std<span class="token punctuation">;</span><span class="token keyword">int</span> M<span class="token punctuation">,</span>N<span class="token punctuation">,</span>T<span class="token punctuation">;</span><span class="token keyword">int</span> locate<span class="token punctuation">[</span><span class="token number">2000000</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定位上一次各个的订单时间</span><span class="token keyword">int</span> prior<span class="token punctuation">[</span><span class="token number">2000000</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储各个店的优先级</span><span class="token keyword">int</span> flag<span class="token punctuation">[</span><span class="token number">2000000</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//标记是否满足优先级>5</span><span class="token keyword">struct</span> store<span class="token punctuation">{</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>   <span class="token keyword">int</span> ts<span class="token punctuation">;</span><span class="token punctuation">}</span>store<span class="token punctuation">[</span><span class="token number">200000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span>  <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">struct</span> store a<span class="token punctuation">,</span><span class="token keyword">struct</span> store b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>ts<span class="token operator">==</span>b<span class="token punctuation">.</span>ts<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>id<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>ts<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>ts<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> cin<span class="token operator">>></span>N<span class="token operator">>></span>M<span class="token operator">>></span>T<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>       cin<span class="token operator">>></span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ts<span class="token operator">>></span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span>   <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>store<span class="token punctuation">,</span>store<span class="token operator">+</span>M<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ts<span class="token operator">!=</span>locate<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>        prior<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">=</span> prior<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">(</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ts<span class="token operator">-</span>locate<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果当前数组的时刻与当前数组对应的ID店的上一次订单时间不相等，就减去对应相差的时间。</span>       prior<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">=</span> prior<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">?</span><span class="token number">0</span><span class="token operator">:</span> prior<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//防止优先级&lt;0</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>prior<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>         flag<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//标记优先级</span>       prior<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//优先级+2</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>prior<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">5</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>           flag<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//标记优先级</span>       locate<span class="token punctuation">[</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token operator">=</span>store<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>ts<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前时间判断完了，就将当前时间设置为该ID店的最后一次订单时间。用于下一次比较</span>   <span class="token punctuation">}</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>locate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>T<span class="token punctuation">)</span>     <span class="token punctuation">{</span>         prior<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> prior<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">(</span>T<span class="token operator">-</span>locate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>prior<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">)</span>        flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>         ans<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里我非常有必要解释一下为什么prior[store[i].id]= prior[store[i].id]-(store[i].ts-locate[store[i].id]) +1;这段代码要+1。我们知道这段代码的功能其实是想要求出两段时间相差了多少，比如6-9中间相差了2个数字，我们直接9-6求出来是等于3的，这个3其中也把9算了进去，但是由于我们到达9的时候是要加优先级的，所以我们要把多减掉的一位给它加回来 </p><blockquote><p>图解：</p><blockquote><p><img src="https://img1.imgtp.com/2023/09/16/jSuykp4O.png"></p></blockquote></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔(hanio tower)递归实现的原理思考</title>
      <link href="/2023/08/27/%E6%B1%89%E8%AF%BA%E5%A1%94(hanio%20tower)%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%9D%E8%80%83/"/>
      <url>/2023/08/27/%E6%B1%89%E8%AF%BA%E5%A1%94(hanio%20tower)%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1><span id="han-nuo-ta-hanio-tower-di-gui-shi-xian-de-yuan-li-si-kao">汉诺塔(hanio tower)递归实现的原理思考</span><a href="#han-nuo-ta-hanio-tower-di-gui-shi-xian-de-yuan-li-si-kao" class="header-anchor">#</a></h1><h2><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h2><blockquote><p>昨天我是先看的汉诺塔理论上的实现原理，看完之后感觉还行，这不是挺简单的嘛。但是理论总归要去实际操作去实现的嘛。于是我就去看了汉诺塔的代码实现方法，看了之后说实话我有点懵逼.WTF？？？？？这么神奇？？就几句话就搞定啦？？凭什么递归就可以去实现汉诺塔?递归和汉诺塔实现原理的共性是什么，以至于递归就可以完美实现汉诺塔？？这些疑问困扰着我。然后我就去搜集有关的视频和文章，结果就是…我还是没理解真正的原理..很多博主的讲解普遍集中在将汉诺塔去一步一步实现了一遍，没有明确提到为什么选择递归算法就可以完美实现汉诺塔。后来，我通过对这些博主讲解的信息进行综合分析，总算有了一点小小的理解。下面我就来分享一下我的个人理解。</p></blockquote><h2><span id="han-nuo-ta-jie-shao">汉诺塔介绍</span><a href="#han-nuo-ta-jie-shao" class="header-anchor">#</a></h2><blockquote><p>汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子(A,B,C)，在一根柱子(A)上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子(B)上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p><strong>根据上文我们可以捕获汉诺塔五点关键信息:①我们有三根柱子分别标记为A,B,C。②A柱子上有从上到下依次增大的圆盘。③我们要将A柱子上的圆盘转移到C柱子上，转移之后盘子形状还是从上到下依次增大。④过程中可以通过B柱子去临时存放。⑤盘子在转移过程中小的盘子只能在大盘子的上方。</strong></p></blockquote><h2><span id="han-nuo-ta-de-yuan-li-shi-xian">汉诺塔的原理实现</span><a href="#han-nuo-ta-de-yuan-li-shi-xian" class="header-anchor">#</a></h2><blockquote><p>话不多说，汉诺塔实在有点抽象，接下来我将通过结合动态图片进行对汉诺塔的实现原理的介绍</p></blockquote><blockquote><hr><p>我的总体讲解原则是，由简入繁。所以我们先从一片圆盘（n=1）开始讲起<br><img src="https://img1.imgtp.com/2023/08/27/9GS5fnYF.gif" alt="n=1时汉诺塔运行情况"></p><blockquote><p><strong>图中我们可以看到当n=1的时候，我们是可以把A柱子移到C柱子达到目标，这个简单我提一嘴就一笔带过了</strong></p></blockquote></blockquote><hr><blockquote><p><strong>接下来我们来看n=2的时候的运行情况</strong></p></blockquote><hr><blockquote><p><img src="https://img1.imgtp.com/2023/08/27/UMrA2XCP.gif" alt="n=2"></p></blockquote><blockquote><p>由图中我们可以看出当A柱的总盘子数大于1的时候，要使从盘子原封不动从A柱移动到C柱子。且大盘子只能在小盘子下面，那我们只能先把上面的小盘子先暂时存到B柱作为过渡，然后我们就可以把A柱上的最大的盘子移动到C柱子，最后把B柱子上的小盘子移动到C柱子就可以了。我们通过总结这段运行过程可以发现：我们只要将n-1个盘子，(n代表最底下的盘子),一次性移动到B柱子上进行过渡，然后第n个盘子移动到C柱子就可以了，然后再把B柱上的盘子整体移动到C柱子就可以完成了。<strong>用更精简的语言来描述就是：先A-&gt;B，然后A-&gt;C，最后B-&gt;C</strong></p></blockquote><hr><blockquote><p>我们再来看一个n=3的运行图</p></blockquote><hr><blockquote><p><img src="https://img1.imgtp.com/2023/08/27/7RenKV1D.gif" alt="n=3"></p></blockquote><hr><blockquote><p>怎么样？看完了n=3的动图演示，是不是感觉一脸懵逼？？？(反正我昨天是这样的qwq)。话不多说，我就来一步一步拆解一下n=3的运行机理。在这之前呢，我们要明确一下我们在n=2的时候得出的结论：<strong>先A-&gt;B，然后A-&gt;C，最后B-&gt;C。这个法则将贯穿全文，无论n的值为多少</strong></p></blockquote><hr><h3><span id="yuan-li-fen-xi">原理分析</span><a href="#yuan-li-fen-xi" class="header-anchor">#</a></h3><p><strong>这里我提前说明一下，我定义最左边的柱子为A，中间的柱子为B，最右边的柱子为C</strong></p><h4><span id="di-yi-bu-chai-jie">第一步拆解</span><a href="#di-yi-bu-chai-jie" class="header-anchor">#</a></h4><blockquote><p>我们知道n=2的时候，程序的运行步骤是先从A-&gt;B将(n-1)部分的盘子移动到B柱寄存，然后执行A-&gt;C，将最底下标号为n的盘子移动到C，最后执行B-&gt;C将寄存在B柱子的(n-1)个柱子移动到C柱子。那我们分析n=3的时候我们就可以将下图蓝色盘子上方的盘子（图中阴影部分）抽象成一个整体，那我们要求的n=3，3个盘子的转移问题就变成了n=2转移两个盘子的问题。</p></blockquote><p><img src="https://img1.imgtp.com/2023/08/27/o63KqaR9.png" alt="@抽象前 "><br><img src="https://img1.imgtp.com/2023/08/27/Ks1MaTNd.png" alt="@抽象后"></p><blockquote><p>接下来我们将抽象后的盘子进行转移，按照n=2的转移办法，粉色的盘子会被投放到B柱子上，然后蓝色的盘子将会被投放到C柱子上。(状态图如下图)<br><img src="https://img1.imgtp.com/2023/08/27/AVIQpxBA.png" alt="@状态图"><br>到了这个状态之后，按照转移的顺序，我们应该把粉色的盘子转移到C柱就可以完成任务了。但是！我们这个粉色的盘子是我们抽象出来的，它内部还有俩盘子呢：所以我们要对着两个盘子再次进行分析。</p><blockquote><p><img src="https://img1.imgtp.com/2023/08/27/mB8iVUkq.png" alt="@粉色盒子内部"></p></blockquote></blockquote><h4><span id="di-er-bu-chai-jie">第二步拆解</span><a href="#di-er-bu-chai-jie" class="header-anchor">#</a></h4><blockquote><p><strong>由于第一步我们是将蓝色盘子上方的两个盘子抽象成了一个，我们程序执行的时候可不能整体移动，所以我们要对这个粉色的整体盘子再次进行拆解，根据第一步拆解的最后步骤我们可以看到，我们第二步拆解的时候，粉色盘子是位于B柱子的时候进来的，那个视角的参照物我们是基于粉色和蓝色盘子的视角(主视角)来看的。所以从那个视角来看，我们的粉色盘子是从B柱子进入第二步拆解。既然我们进入了第二步拆解，我们的视角参照物应该切换成基于黄色和绿色盘子的视角(次视角)，我们要从这个视角来重复执行A-&gt;B,A-&gt;C，B-&gt;C的步骤，但是这里要注意，我们最终的观察角度是通过主视角来看的，于是主视角所看到的B柱子其实对应的是次视角的C柱子：因为我们是从主视角的B柱子进入的次视角，在次视角中最后是要将盘子从A-&gt;C，随后返回给主视角，所以说次视角的C相当于主视角的B柱子，次视角的B相当于主视角的C柱子。接下来我们通过图片来加深一下理解</strong><br>如下图。<br><img src="https://img1.imgtp.com/2023/08/27/TMGmviqi.png" alt="@二次拆解后，次视角"><br>接下来我们来看一下次视角状态下盘子移动后的A-&gt;B，A-&gt;C的中间结果<br><img src="https://img1.imgtp.com/2023/08/27/ejF9lz1G.gif" alt="@次视角中进行移动的中间结果图"><br>那我们的主视角是什么样的情况呢，接下来我们来看一下次视角对应的主视角盘子移动情况<br><img src="https://img1.imgtp.com/2023/08/27/TrZMAKdX.gif" alt="@主视角中进行移动的中间结果图"></p></blockquote><blockquote><p><strong>看到这里我们相信你就明白了吧，每一次对抽象盘子进行拆解的时候，它们都会进入以抽象盘子为基础的次视角，但是我们从外部来看到的应该是没有拆解前的主视角的移动情况。所以啊，我们再看看一遍n=3的时候的运行图，来加强一下理解。我觉得最难的点在于我们人总是会惯性地从我们的主视角去看，而每一次拆解进入的时候是抽象盘子的次视角在执行A-&gt;B,A-&gt;C，B-&gt;C的迁移动作。这导致了我们看的很懵逼，越看越难理解。</strong><br><img src="https://img1.imgtp.com/2023/08/27/7RenKV1D.gif" alt="n=3"></p></blockquote><p>好了，思路到这里我们点到为止，大致的运行思路就是这样，关键在于主次视角的切换的理解，接下来我们将为什么用递归来实现汉诺塔</p><h2><span id="wei-shi-me-yong-di-gui-suan-fa-shi-xian">为什么用递归算法实现？</span><a href="#wei-shi-me-yong-di-gui-suan-fa-shi-xian" class="header-anchor">#</a></h2><blockquote><p>要解决这个疑问呢，我们首先要搞明白，汉诺塔的盘子的迁移特性和递归的特性，它们两者之间的有没有共通性才是我们选择递归来实现汉诺塔的关键。那下面我来分析一下，看看它们之间是不是真的有共通点</p></blockquote><blockquote><p>汉诺塔盘子的迁移特性</p><blockquote><p>我们通过对两个以上的盘子进行抽象，让我们把要解决的问题转换成一个个n=2的盘子迁移问题，直到n=1为止。比如我们总的n=3，那我们第一步就要把三个盘子中的两个抽象成1个，保留最底下的那个盘子。这样我们要解决的问题又变成了解决n=2的盘子迁移问题。换句话来我们将复杂的问题，通过层层外包进行了分布化处理</p></blockquote></blockquote><blockquote><p>递归的特性</p><blockquote><p>递归可以类比成公司领导下发秘密任务，通过层层下属的反馈最后达到完成任务的目的。假如老板A准备发了一则秘密任务“test”，于是老板把他的亲信”B”高管叫过来了，说你去帮我完成，完成后给予他反馈。然后”B”高管肯定也不会自己干的，于是它就把任务告诉了他的亲信”C“，让C完成之后给予反馈。</p></blockquote></blockquote><blockquote><p>怎么样？看了汉诺塔的迁移特性和递归的特性，有没有发现他们其实都是在通过层层外包，最后将问题转换成最简单的问题再去解决。最后达到将复杂的问题简单化的目标。所以我们完全可以使用递归算法去实现汉诺塔问题！！</p></blockquote><h2><span id="dai-ma-shi-xian">代码实现</span><a href="#dai-ma-shi-xian" class="header-anchor">#</a></h2><blockquote><p>知道了为什么能用递归算法实现汉诺塔问题，接下来我们就来感受一下在代码下的汉诺塔实现，这里我给出两个版本，一个是python版本，一个是c++版本。</p></blockquote><hr><blockquote><p>c++版本</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">,</span><span class="token keyword">char</span> y<span class="token punctuation">,</span><span class="token keyword">char</span> z<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//x，y，z分别代表A,B,C柱子</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum<span class="token operator">++</span><span class="token punctuation">;</span>       cout<span class="token operator">&lt;&lt;</span><span class="token string">"#"</span><span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span><span class="token string">": "</span><span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>z<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//A->C</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//当n=1，也就是只有一个盘子的时候我们直接把盘子丢给C柱子即可</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//否则我们就要进入else语句，通过不断的抽象化盘子，去简化问题</span>        <span class="token function">hanoi</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>z<span class="token punctuation">,</span>y<span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽象化盘子将A->B柱子</span>        sum<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"#"</span><span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span><span class="token string">": "</span><span class="token operator">&lt;&lt;</span>x<span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>z<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行完抽象化的盘子之后，这里我们是将最底下的那个盘子直接移动到C柱子上</span>        <span class="token function">hanoi</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>x<span class="token punctuation">,</span>z<span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最底下的盘子我们已经在上面移动到了C柱子，接下来我们把暂存在B柱子的盘子移动到C柱子就好了，这段代码就是实现这个功能B->C柱子</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token operator">>></span>m<span class="token punctuation">;</span>    <span class="token function">hanoi</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当我们执行抽象化盘子从B柱子-&gt;柱子C的时候</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">hanoi</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>x<span class="token punctuation">,</span>z<span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最底下的盘子我们已经在上面移动到了C柱子，接下来我们把暂存在B柱子的盘子移动到C柱子就好了，这段代码就是实现这个功能</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>程序通过递归下一次会进入A-&gt;B柱的代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">hanoi</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>z<span class="token punctuation">,</span>y<span class="token punctuation">,</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抽象化盘子将A->B柱子</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>**发现没有？这里有一个主次视角的转换。我来举个例子好了比如我们先执行hanoi(y,x,z,n-1); 这里y=B,x=A，z=C，代入可以得到hanoi(B,A,C,n-1);，接着执行hanoi(x,z,y,n-1); 这里我们将刚刚函数读入的x，y，z对应填入这个函数，可以得到hanoi(A,,C,B,n-1); 文字有点不好描述，请看下面的动图演示：(还是以n=3进入n=2的数据作为例子)</p><p><img src="https://img1.imgtp.com/2023/08/28/RUvp66U4.gif" alt="n=3进入n=2,n=2的视角"></p><p>所以我们从n=3的主视角看到的就是如下的运动情况：</p><p><img src="https://img1.imgtp.com/2023/08/27/7RenKV1D.gif" alt="n=3的主视角运动情况"></p><p><strong>看到没有！！主视角的黄色盘子第一步移动就去了C盘子，C盘子就对应了次视角的B盘子</strong></p></blockquote><hr><blockquote><p>Python版本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token string">"--->"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token operator">//</span>解决当盘子只剩一个的时候的迁移问题    <span class="token keyword">else</span><span class="token punctuation">:</span>        move<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>c<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">//</span>将抽象化的盘子从A<span class="token operator">-</span><span class="token operator">></span>B        <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token string">"--->"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token operator">//</span>把最底下的盘子从A<span class="token operator">-</span><span class="token operator">></span>C柱子        move<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>b<span class="token punctuation">,</span>a<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token operator">//</span>把抽象的盘子从B<span class="token operator">-</span><span class="token operator">></span>C柱子<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2><span id="xie-zai-zui-hou">写在最后</span><a href="#xie-zai-zui-hou" class="header-anchor">#</a></h2><blockquote><p>我只能说汉诺塔这个问题，如果单纯告诉程序去运行思路，那看起来是挺简单的，但是深入思考它内部的运行原理是挺抽象的，因为里面涉及了主次视角的转变，而我们又总是以主视角去观察盘子移动的，这就让人感觉产生了汉诺塔运行起来毫无规律的误解。以上就是我对汉诺塔的个人理解。本人水平有限。如果理解错了，请见谅，欢迎指正。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表题实战</title>
      <link href="/2023/08/25/%E9%93%BE%E8%A1%A8%E5%AE%9E%E6%88%98/"/>
      <url>/2023/08/25/%E9%93%BE%E8%A1%A8%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1><span id="lian-biao-shi-zhan">链表实战</span><a href="#lian-biao-shi-zhan" class="header-anchor">#</a></h1><h2><span id="ti-mu-miao-shu">题目描述</span><a href="#ti-mu-miao-shu" class="header-anchor">#</a></h2><blockquote><p>有 n 辆自行车依次来到停车棚，除了第一辆自行车外，每辆自行车都会恰好停放在已经在停车棚里的某辆自行车的左边或右边。(e.g.停车棚里已经有 3 辆自行车，从左到右编号为:3,5,1。现在编号为 2 的第 4 辆自行车要停在 5 号自行车的左边，所以现在停车棚里的自行车编号是：3，2，5，1）。给定n辆自行车的停放情况，按顺序输出最后停车棚里的自行车编号。n≤100000。</p></blockquote><blockquote><p><strong>输入描述</strong></p><blockquote><p>第一行一个整数 n。 第二行一个整数x。表示第一辆自行车的编号。 以下 n−1 行，每行<br>3 个整数 x,y,z。 z=0 时，表示编号为 x 的自行车恰停放在编号为 y 的自行车的左边。 z=1 时，表示编号为 x 的自行车恰停放在编号为 y 的自行车的右边。</p></blockquote></blockquote><blockquote><p><strong>输出描述</strong></p><blockquote><p>从左到右输出停车棚里的自行车编号</p></blockquote></blockquote><blockquote><p><strong>输入样例</strong></p><blockquote><pre><code>        4    3  1 3 1  2 1 0  5 2 1</code></pre></blockquote></blockquote><blockquote><p><strong>输出样例</strong></p><blockquote><pre><code>3 2 5 1</code></pre></blockquote></blockquote><h2><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h2><h3><span id="jing-tai-lian-biao-shi-xian-si-lu">静态链表实现思路</span><a href="#jing-tai-lian-biao-shi-xian-si-lu" class="header-anchor">#</a></h3><blockquote><p><strong>①：先初始化下标为0,1的链表结点。</strong><br><strong>如图</strong>   <img src="https://img1.imgtp.com/2023/08/25/BsOFIdEf.jpg" alt="初始化示意图"></p></blockquote><blockquote><p><strong>②：接下来我们从下标为2的链表结点开始，先将第一辆自行车插入结点0和结点1之间。之后保持结点0，1不动，结点0，1仅仅用于判别左右方向边界。</strong><br><img src="https://img1.imgtp.com/2023/08/25/hldOBjyF.jpg" alt="链表插入示意图"><br><strong>③：由于链表在插入的时候需要一个一个遍历过去，它的时间复杂度是O(n)，n题目说是≤100000 。当n过大时，容易引起程序运行超时。所以我们引进一个located[N]定位数组，用于定位每个自行车的位置。这样我们就可以根据自行车的名字直接定位到其结点位置进行插入操作，无需进行遍历查找。</strong><br><strong>④：结合以上三点，我们就可以实现对本题的代码实现</strong></p></blockquote><h2><span id="he-xin-dai-ma">核心代码</span><a href="#he-xin-dai-ma" class="header-anchor">#</a></h2><blockquote><p>创建链表</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Node<span class="token punctuation">{</span>  <span class="token keyword">int</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储上一个结点</span>  <span class="token keyword">int</span> N<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储下一个结点</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储自行车的编号</span><span class="token punctuation">}</span>Node<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>创建一个locate数组用于存储自行车摆放的结点位置，便于快速定位</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> locate<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>编写一个初始化函数，设置链表结点0，1作为左右方向的边界</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> Node<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   Node<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   now<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对应本文上面思路段落的第一张图片</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>编写插入数据的自定义函数，用图片来描述的话，就是对应本文思路部分的第二张图片，本节的代码部分理解最好对着图片去模拟，那样会好理解一点。</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//变量k是提供位置信息，例如x要插入到y的左边，那这个k就代表了y的位置信息。而变量a则提供新插入的自行车的编号</span><span class="token punctuation">{</span> Node<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">=</span>a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将新自行车的编号插入新结点的数据部分</span> locate<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">=</span>now<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将新的自行车结点的下标存储在locate数组，便于快速查找</span> Node<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token operator">=</span>Node<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将新结点的N（next）指向新结点右边的结点</span> Node<span class="token punctuation">[</span>Node<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span>now<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将刚刚新节点的N指向的右边结点重新指回新结点，以构成双向链表，方便结点左右方向的任意插入</span> Node<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token operator">=</span>now<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将属于新节点左边的结点指向新结点</span> Node<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span>k<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新节点的P（preid）指向其左结点。</span> now<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//结点位置+1，便于下一个新结点的创建。</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这个代码需要结合思路部分的第二张图片去理解更佳</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>对于左右插入顺序的执行，在插入函数中最后的实现其实是偏右边的，比如k=0，那我们新的结点插入的位置是在0结点的右边的。右边插入我们解决了，接下来我们按照相对性的普遍规律，我们输入k=-1结点(这只是假设，假设0结点前面有一个-1结点)，那结点就会插入到-1结点的右边，这不就相当于在结点0的左边嘛。这样我们左边插入和右边插入的问题就迎刃而解了</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">if</span><span class="token punctuation">(</span>z<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">insert</span><span class="token punctuation">(</span>Node<span class="token punctuation">[</span>locate<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//插入到y的左边</span>      <span class="token punctuation">}</span>    <span class="token keyword">else</span>       <span class="token punctuation">{</span>           <span class="token function">insert</span><span class="token punctuation">(</span>locate<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//插入到y的右边</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">120000</span><span class="token punctuation">;</span><span class="token keyword">int</span> now<span class="token punctuation">;</span><span class="token keyword">struct</span> Node<span class="token punctuation">{</span>  <span class="token keyword">int</span> p<span class="token punctuation">;</span>  <span class="token keyword">int</span> N<span class="token punctuation">;</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> locate<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> Node<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   Node<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   now<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span> Node<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">=</span>a<span class="token punctuation">;</span> locate<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">=</span>now<span class="token punctuation">;</span> Node<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token operator">=</span>Node<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token punctuation">;</span> Node<span class="token punctuation">[</span>Node<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span>now<span class="token punctuation">;</span> Node<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token operator">=</span>now<span class="token punctuation">;</span> Node<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token operator">=</span>k<span class="token punctuation">;</span> now<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> n<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">;</span>  cin<span class="token operator">>></span>n<span class="token punctuation">;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span>  cin<span class="token operator">>></span>a<span class="token punctuation">;</span>  <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将第一辆自行车插入数据</span>  n<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一辆插入了之后总数量要减1</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>      cin<span class="token operator">>></span>x<span class="token operator">>></span>y<span class="token operator">>></span>z<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>z<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token function">insert</span><span class="token punctuation">(</span>Node<span class="token punctuation">[</span>locate<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>p<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">else</span>       <span class="token punctuation">{</span>           <span class="token function">insert</span><span class="token punctuation">(</span>locate<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>Node<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token punctuation">;</span>i<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">=</span>Node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>N<span class="token punctuation">)</span>     <span class="token punctuation">{</span>       cout<span class="token operator">&lt;&lt;</span>Node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将结点的数据依次输出</span>     <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="c-stl-lian-biao-rong-qi-shi-xian-yuan-dai-ma">C++STL 链表容器实现源代码</span><a href="#c-stl-lian-biao-rong-qi-shi-xian-yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">,</span>a<span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator locate<span class="token punctuation">[</span><span class="token number">200000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用于定位自行车对应的结点位置</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Node<span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//迭代器，只访问物体的外部信息，而不访问内部信息，可以看作指针，指针是迭代器的一种</span>    cin<span class="token operator">>></span>n<span class="token operator">>></span>a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//a是第一类自行车的编号，n是总共的自行车数量</span>    Node<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将第一辆自行车的数据存入链表结点</span>    locate<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">=</span>Node<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将第一辆自行车的结点的位置信息存到locate 迭代器中，因为list容器访问的时候只能通过自增去一个一个查询，而不可以直接通过下标去访问。那样太慢了，我们直接通过存自行车编号对应的迭代器，可以直接定位到具体的结点位置，提高运行效率</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> cin<span class="token operator">>></span>x<span class="token operator">>></span>y<span class="token operator">>></span>z<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>z<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>  Node<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>locate<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将编号x的自行车插到y编号自行车的左边</span>            temp<span class="token operator">=</span>locate<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//存储y编号自行车的位置</span>            locate<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">--</span>temp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//temp位置是对应y自行车的，现在x编号的自行车已经在y自行车的前面了，所以只要将temp自减1，就是x对应的位置信息了</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span> Node<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">++</span>locate<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将编号x的自行车插到y编号自行车的右边</span>            temp<span class="token operator">=</span>locate<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>            locate<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">--</span>temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    temp<span class="token operator">=</span>Node<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>temp<span class="token punctuation">;</span>temp<span class="token operator">!=</span>Node<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>temp<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//通过迭代器遍历输出结果</span>  <span class="token punctuation">{</span>      cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>temp<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h2><blockquote><p><strong>通过一locate数组/list迭代器 来存储位置信息，通过空间换时间可以用来解决链表遍历过慢的问题。本题核心的点在于利用双向链表，通过物体相对的位置关系去实现了左边插入和右边插入。</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数求阶乘/相加问题</title>
      <link href="/2023/08/23/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/23/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1><span id="da-shu-qiu-jie-cheng-xiang-jia-wen-ti">大数求阶乘/相加问题</span><a href="#da-shu-qiu-jie-cheng-xiang-jia-wen-ti" class="header-anchor">#</a></h1><h2><span id="da-shu-qiu-jie-cheng">大数求阶乘</span><a href="#da-shu-qiu-jie-cheng" class="header-anchor">#</a></h2><h3><span id="ti-mu-miao-shu">题目描述</span><a href="#ti-mu-miao-shu" class="header-anchor">#</a></h3><blockquote><p>题目描述<br>给定一个正整数 n，求出 n! 的值。<br><strong>输入描述</strong></p></blockquote><blockquote><p>输入一个正整数 n，n&lt;=1000。</p></blockquote><blockquote><p><strong>输出描述</strong><br>输出 n! 。<br><strong>输入输出样例</strong></p><blockquote><p>示例<br>输入</p></blockquote><blockquote><blockquote><pre><code>10</code></pre></blockquote></blockquote></blockquote><blockquote><blockquote><p>输出</p><blockquote><pre><code>3628800</code></pre></blockquote></blockquote></blockquote><h3><span id="jie-ti-si-lu">解题思路</span><a href="#jie-ti-si-lu" class="header-anchor">#</a></h3><blockquote><p>刚看到这道题目的时候，我的内心：什么？？求阶乘？？？这个简单，写一个采用递归的方法，递归不就完事了嘛。一分钟以后，我毫不犹豫点击提交，一看，就通过了俩测试点 (大哭.jpg)。既然出了问题，那就得先找出是什么原因导致的，题目说n&lt;=1000。那我就拿n=1000去测试一下程序，一看数据结果是鸭蛋(0)。到这里基本上问题就明朗了，当n越来越大的时候，前几个小的数还可以正常输出，后面的大的数据所计算出来的阶乘值已经超过了定义的int类型的最大范围，导致结果溢出。n=1000的时候即使是long long 类型的数据类型也无法承受它的结果值。好家伙，突然感觉路就被堵死了，这咋办？既然问题是大的数据溢出造成的，那我们干脆就把这个大的数据存放进数组里面，这样就可以保证数据不溢出了。那新的问题又来了，这个大数被我们存进数组了，那我们怎么让它跟下一个数据进行相乘呢？？？？好在天无绝人之路，小学学的竖式相乘的法则可以帮我们完美解决这个问题。接下来我们来介绍一下这个竖式相乘法则：</p><blockquote><p>直接放例子:  12×39916878</p></blockquote></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">         <span class="token number">12</span>   <span class="token number">39916878</span>       <span class="token comment" spellcheck="true">//第一步先将两个数对应的位数对齐(个位对个位，十位对十位......)</span>         <span class="token number">96</span>      <span class="token comment" spellcheck="true">//第二步接下来我们让大数的个位数8去乘12,可得到96</span>        <span class="token number">84</span>      <span class="token comment" spellcheck="true">//同理我们让大数的十位上的数7去乘12,可得到84</span>       <span class="token number">96</span>      <span class="token comment" spellcheck="true">//百位上的数也同理</span>      <span class="token number">72</span>      <span class="token comment" spellcheck="true">//千位上的数也同理</span>     <span class="token number">12</span>      <span class="token comment" spellcheck="true">//万位上的数也同理</span>   <span class="token number">108</span>      <span class="token comment" spellcheck="true">//十万位上的数也同理</span>  <span class="token number">108</span>      <span class="token comment" spellcheck="true">//百万位位上的数也同理</span>  <span class="token number">36</span>      <span class="token comment" spellcheck="true">//千万位上的数也同理</span>  <span class="token number">479002536</span>        <span class="token comment" spellcheck="true">//最后我们依次把这些数相加存入数组就可以得到结果了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>这个竖式相乘法则就是解决我们本题的关键，看了上面的这个例子，相信你心中应该已经有点灵感了吧？？如果没有也没关系，接下来我们用程序语言来实现这个算法</strong></p></blockquote><hr><blockquote><p> <strong>首先我们要初始化一个数组，记作Big_data;同时初始化当前数据每个位数上的数字，这里我们为了直观一点，将大数的个位数设置在数组下标1的位置，十位、百位…..则对应数组下标2、3……</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">int</span> Big_data<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span> <span class="token keyword">int</span> n，i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//n用于所需阶乘的数据输入，i和j是为了下面的数据遍历</span> cin<span class="token operator">>></span>n<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>接下来我们要进行第二步：将依次递增上去的较小数与大数的各个位进行相乘，将各个位数的结果存储在位数对应的数组中</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>last<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个操作是让每个 位数产生的乘积先临时存入数组中，以上面的数据为例子，个位数产生的乘积96将被存入数组下标1中，下标2将存入十位上产生的乘积84，以此类推。</span>        <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>第三步：每个位置上的乘积我们已经储存好了，接下来我们就要对这些存储好的数组数据进行相加处理了</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>last<span class="token operator">||</span>Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这里的Big_data[j]!=0是为了让两数相乘之后的最高位上的数据能够更新,本来我们相乘之前那个大数是个8位数，那我们j能遍历到的最高位也就是八，如果相乘的数结果是个9位数的话，那最高位就没办法添加进我们的最高位数组，所以这个Big_data[j]!=0就是为了当j==9的时候如果Big_data[9]不是0的话，说明新的大数是有九位数的，所以我们要进入这个条件，把第九位数据更新进Big_data数组</span><span class="token punctuation">{</span> Big_data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>Big_data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token punctuation">(</span>Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//以上面的个位和十位数举例子就是让96中的9和84去相加</span>  Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新大数每个位置上的数据，以上面的例子的个位数就是96的9已经加进84了，剩下的6就是我们个位数上剩的值了，那我们把6添加进Big_data[1]，作为我们的个位。</span> <span class="token punctuation">}</span> last<span class="token operator">=</span>j<span class="token number">-1</span><span class="token comment" spellcheck="true">//更新这个大数的最高位数值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>到这里数据已经被我们处理完成了，此时Big_data数组中下标1-last中已经存了我们这个大数的各个位数的数值，我们只要全部把他们输出了就可以得到我们这个大数的值了。</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>last<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>   cout<span class="token operator">&lt;&lt;</span>Big_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//依次输出大数各个位数上的值</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> last<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">int</span> Big_data<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>last<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>last<span class="token operator">||</span>Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> Big_data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>Big_data<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>          Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>Big_data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        last<span class="token operator">=</span>j<span class="token number">-1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>last<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      cout<span class="token operator">&lt;&lt;</span>Big_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//依次输出大数各个位数上的值</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="da-shu-xiang-jia-wen-ti">大数相加问题</span><a href="#da-shu-xiang-jia-wen-ti" class="header-anchor">#</a></h2><h3><span id="ti-mu-miao-shu">题目描述</span><a href="#ti-mu-miao-shu" class="header-anchor">#</a></h3><blockquote><p>输入两个整数 a 和 b，输出这两个整数的和。a 和 b 都不超过 100 位</p></blockquote><h3><span id="jie-ti-si-lu">解题思路</span><a href="#jie-ti-si-lu" class="header-anchor">#</a></h3><blockquote><p>本题解题的原理与上面的竖式乘法原理类似，让程序模拟竖式加法去运算即可。下面我来简单介绍一下竖式加分：</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token number">89789</span><span class="token operator">+</span> <span class="token number">78979</span>     <span class="token number">18</span>    <span class="token number">15</span>   <span class="token number">16</span>  <span class="token number">17</span> <span class="token number">15</span><span class="token operator">=</span><span class="token number">168768</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>第一题求大数阶乘的时候我们是从1开始逐次乘上去的，所以我们可以选择让个位数从数组的 下标1开始，而本题是直接通过输入两个大数，如果采用整数数组法，还需要去确认输入数据的位数，操作起来比较麻烦。所以本题我们代码部分采用另外一种字符串写法去执行：</p></blockquote><hr><blockquote><p><strong>首先我们先定义输入a,b，以及相加结果add_result的类型为字符串</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">string add_result<span class="token punctuation">;</span> string a <span class="token punctuation">,</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>接下来我们同样地从a，b两个字符串的末尾(大数的个位数)开始执行竖式加法原则，由于我们数据类型是字符类型的，所以数据的各个位数上对应的字符就要合理加减字符’0’去间接地转成整数，才可以让对应各个位数进行相加。我在源代码中引进了int c 整型变量用来临时存储位数相加之后的数据。然后我们可以通过对变量c的取余与字符’0’相加，我们就可以使各个位数上的结果还原成字符类型了。这样我们就可以解决字符之间相加的难题了。</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">||</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">||</span>c<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">,</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从后往前遍历，相当于从个位数开始依次往前遍历，c!=0也是为了如果最高位有进位值的话，要更新最高位的数据</span> <span class="token punctuation">{</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果a上面的位数有数据，则将该字符与字符'0'相减，得到差值（字符间接转整数），方便两个大数位数之间的相加</span>    c<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果b上面的位数有数据，则将该字符与字符'0'相减，得到差值，（字符间接转整数），方便两个大数位数之间的相加</span>    c<span class="token operator">+</span><span class="token operator">=</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>    add_result<span class="token operator">+</span><span class="token operator">=</span>c<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token string">'0'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将相加后的得出的位数结果值还原成字符类型</span>    c<span class="token operator">=</span>c<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 进位值，加入到下一位的数据相加之中去</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>到这里我们add_result存储的结果其实是从个位开始然后到高位的，所以我们输出的时候要把这个字符串翻转一下再输出</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token function">reverse</span><span class="token punctuation">(</span>add_result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>add_result<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将字符串add_result翻转过来</span> cout<span class="token operator">&lt;&lt;</span>add_result<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> string add_result<span class="token punctuation">;</span> string a <span class="token punctuation">,</span>b<span class="token punctuation">;</span> <span class="token keyword">int</span> c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> cin<span class="token operator">>></span>a<span class="token operator">>></span>b<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">=</span>b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">||</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">||</span>c<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">,</span>j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span>    c<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span>    c<span class="token operator">+</span><span class="token operator">=</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>    add_result<span class="token operator">+</span><span class="token operator">=</span>c<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token string">'0'</span><span class="token punctuation">;</span>    c<span class="token operator">=</span>c<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">reverse</span><span class="token punctuation">(</span>add_result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>add_result<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span>add_result<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h2><blockquote><p><strong>这两道题目虽然代码的处理方式不一样，但是他们的原理都是基于竖着乘法(加法)法则来运行的，无论是加法还是乘法，我们都是要从个位开始操作，第一题求阶乘的时候我们是从1开始逐次乘上去的，相当于就是从个位数开始的，所以我们可以利用数组来从左向右依次存储大数的低位到高位的数据情况。最后输出的时候将各个位数数据反过来输出即可。而第二题两个大数相加，由于他们是通过键盘输入进来的数据，输入进来的位数从高到低是依次从左向右排列的。但是我们相加的过程毕竟还是要从个位数开始执行的，我们还要去确定两个大数的个位数的位置下标，比较繁琐。所以我们换了一种思路，通过将两个数定义成字符串类型，通过字符串的size()方法名，找到字符串的长度，然后从后往前遍历，且通过加减字符’0’，来间接实现对字符数据之间的相加减。最后将结果字符串翻转输出即可。</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 大数运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯小题杂记</title>
      <link href="/2023/08/22/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E9%A2%98%E6%9D%82%E8%AE%B0/"/>
      <url>/2023/08/22/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E9%A2%98%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1><span id="lan-qiao-bei-xiao-ti-za-ji">蓝桥杯小题杂记</span><a href="#lan-qiao-bei-xiao-ti-za-ji" class="header-anchor">#</a></h1><h2><span id="ti-mu">题目①</span><a href="#ti-mu" class="header-anchor">#</a></h2><h3><span id="ti-mu-miao-shu">题目描述</span><a href="#ti-mu-miao-shu" class="header-anchor">#</a></h3><blockquote><p>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。<br>如下的 10行数据，每行有 10 个整数，请你求出它们的乘积的末尾有多少个零？</p><p><strong>5650 4542 3554 473 946 4114 3871 9073 90 4329<br>2758 7949 6113 5659 5245 7432 3051 4434 6704 3594<br>9937 1173 6866 3397 4759 7557 3070 2287 1453 9899<br>1486 5722 3135 1170 4014 5510 5120 729 2880 9019<br>2049 698 4582 4346 4427 646 9742 7340 1230 7683<br>5693 7015 6887 7381 4172 4341 2909 2027 7355 5649<br>6701 6645 1671 5978 2704 9926 295 3125 3878 6785<br>2066 4247 4800 1578 6652 4616 1113 6205 3264 2915<br>3966 5291 2904 1285 2193 1428 2265 8730 9436 7074<br>689 5510 8243 6114 337 4096 8199 7313 3685 211</strong></p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><blockquote><p>题目说要求这100个数据的乘积有多少个零，如果我们直接将这些数据相乘，那将会是一个天文数字，肯定会超出数据类型的最大值。那怎么办？一种显而易见的方式是：分而治。首先：先将摆在明面上的数据有零的先提早进行计数，计数完之后将数据记完数的含零部分进行剔除。所有数据按照这种思路执行，直到遍历完成。 其次：根据两数相乘的法则，同时图中数据最大的位数是4位数，我们还可以在去除完多余的0数据之后只保留该数据（被乘数）的最后四位。因为乘数最大是四位数，与被乘数的有效乘积其实只有四位，所以我们完全可以去除该数据（被乘数）的冗余位数。至此我们就实现了在保证数据不超出类型的最大值的情况下完成了对总乘积值的零数据的计数。</p></blockquote><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化全局计数变量count</span><span class="token keyword">int</span> <span class="token function">DivideZero</span><span class="token punctuation">(</span><span class="token keyword">int</span>  i<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">/</span><span class="token number">10</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//遍历数据的每一个位数</span>    <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">10</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果该位是0，则计数+1</span>    <span class="token punctuation">{</span>      count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token comment" spellcheck="true">//如果该位数不是0，则直接返回这个数的值</span>     <span class="token keyword">return</span> i<span class="token punctuation">;</span>        i<span class="token operator">=</span>i<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除判断完的位数</span>    <span class="token punctuation">}</span>      <span class="token keyword">return</span>  i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果这个位数除了最高位之外都是0，只剩该最高位，则返回这个最高位的值</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">103</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>   <span class="token number">5650</span><span class="token punctuation">,</span><span class="token number">4542</span><span class="token punctuation">,</span><span class="token number">3554</span><span class="token punctuation">,</span><span class="token number">473</span><span class="token punctuation">,</span><span class="token number">946</span><span class="token punctuation">,</span><span class="token number">4114</span><span class="token punctuation">,</span><span class="token number">3871</span><span class="token punctuation">,</span><span class="token number">9073</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">4329</span><span class="token punctuation">,</span>   <span class="token number">2758</span><span class="token punctuation">,</span><span class="token number">7949</span><span class="token punctuation">,</span><span class="token number">6113</span><span class="token punctuation">,</span><span class="token number">5659</span><span class="token punctuation">,</span><span class="token number">5245</span><span class="token punctuation">,</span><span class="token number">7432</span><span class="token punctuation">,</span><span class="token number">3051</span><span class="token punctuation">,</span><span class="token number">4434</span><span class="token punctuation">,</span><span class="token number">6704</span><span class="token punctuation">,</span><span class="token number">3594</span><span class="token punctuation">,</span>   <span class="token number">9937</span><span class="token punctuation">,</span><span class="token number">1173</span><span class="token punctuation">,</span><span class="token number">6866</span><span class="token punctuation">,</span><span class="token number">3397</span><span class="token punctuation">,</span><span class="token number">4759</span><span class="token punctuation">,</span><span class="token number">7557</span><span class="token punctuation">,</span><span class="token number">3070</span><span class="token punctuation">,</span><span class="token number">2287</span><span class="token punctuation">,</span><span class="token number">1453</span><span class="token punctuation">,</span><span class="token number">9899</span><span class="token punctuation">,</span>   <span class="token number">1486</span><span class="token punctuation">,</span><span class="token number">5722</span><span class="token punctuation">,</span><span class="token number">3135</span><span class="token punctuation">,</span><span class="token number">1170</span><span class="token punctuation">,</span><span class="token number">4014</span><span class="token punctuation">,</span><span class="token number">5510</span><span class="token punctuation">,</span><span class="token number">5120</span><span class="token punctuation">,</span><span class="token number">729</span><span class="token punctuation">,</span><span class="token number">2880</span><span class="token punctuation">,</span><span class="token number">9019</span><span class="token punctuation">,</span>   <span class="token number">2049</span><span class="token punctuation">,</span><span class="token number">698</span><span class="token punctuation">,</span><span class="token number">4582</span><span class="token punctuation">,</span><span class="token number">4346</span><span class="token punctuation">,</span><span class="token number">4427</span><span class="token punctuation">,</span><span class="token number">646</span><span class="token punctuation">,</span><span class="token number">9742</span><span class="token punctuation">,</span><span class="token number">7340</span><span class="token punctuation">,</span><span class="token number">1230</span><span class="token punctuation">,</span><span class="token number">7683</span><span class="token punctuation">,</span>   <span class="token number">5693</span><span class="token punctuation">,</span><span class="token number">7015</span><span class="token punctuation">,</span><span class="token number">6887</span><span class="token punctuation">,</span><span class="token number">7381</span><span class="token punctuation">,</span><span class="token number">4172</span><span class="token punctuation">,</span><span class="token number">4341</span><span class="token punctuation">,</span><span class="token number">2909</span><span class="token punctuation">,</span><span class="token number">2027</span><span class="token punctuation">,</span><span class="token number">7355</span><span class="token punctuation">,</span><span class="token number">5649</span><span class="token punctuation">,</span>   <span class="token number">6701</span><span class="token punctuation">,</span><span class="token number">6645</span><span class="token punctuation">,</span><span class="token number">1671</span><span class="token punctuation">,</span><span class="token number">5978</span><span class="token punctuation">,</span><span class="token number">2704</span><span class="token punctuation">,</span><span class="token number">9926</span><span class="token punctuation">,</span><span class="token number">295</span><span class="token punctuation">,</span><span class="token number">3125</span><span class="token punctuation">,</span><span class="token number">3878</span><span class="token punctuation">,</span><span class="token number">6785</span><span class="token punctuation">,</span>   <span class="token number">2066</span><span class="token punctuation">,</span><span class="token number">4247</span><span class="token punctuation">,</span><span class="token number">4800</span><span class="token punctuation">,</span><span class="token number">1578</span><span class="token punctuation">,</span><span class="token number">6652</span><span class="token punctuation">,</span><span class="token number">4616</span><span class="token punctuation">,</span><span class="token number">1113</span><span class="token punctuation">,</span><span class="token number">6205</span><span class="token punctuation">,</span><span class="token number">3264</span><span class="token punctuation">,</span><span class="token number">2915</span><span class="token punctuation">,</span>   <span class="token number">3966</span><span class="token punctuation">,</span><span class="token number">5291</span><span class="token punctuation">,</span><span class="token number">2904</span><span class="token punctuation">,</span><span class="token number">1285</span><span class="token punctuation">,</span><span class="token number">2193</span><span class="token punctuation">,</span><span class="token number">1428</span><span class="token punctuation">,</span><span class="token number">2265</span><span class="token punctuation">,</span><span class="token number">8730</span><span class="token punctuation">,</span><span class="token number">9436</span><span class="token punctuation">,</span><span class="token number">7074</span><span class="token punctuation">,</span>   <span class="token number">689</span><span class="token punctuation">,</span><span class="token number">5510</span><span class="token punctuation">,</span><span class="token number">8243</span><span class="token punctuation">,</span><span class="token number">6114</span><span class="token punctuation">,</span><span class="token number">337</span><span class="token punctuation">,</span><span class="token number">4096</span><span class="token punctuation">,</span><span class="token number">8199</span><span class="token punctuation">,</span><span class="token number">7313</span><span class="token punctuation">,</span><span class="token number">3685</span><span class="token punctuation">,</span><span class="token number">211</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  temp<span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//temp临时存储第一个数据，方便用于与后面的数据进行相乘</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>  temp<span class="token operator">*</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前后数据进行相乘</span>   temp<span class="token operator">=</span><span class="token function">DivideZero</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除数据某位的连续的"0"</span>   temp<span class="token operator">=</span>temp<span class="token operator">%</span><span class="token number">10000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//保留数据的后四位，不干扰求末尾0数据总数的同时缩小数据的大小</span>   <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>count<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出总计数值</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="ti-mu">题目②</span><a href="#ti-mu" class="header-anchor">#</a></h2><blockquote><p><strong>题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。  小明对数位中含有 2、0、1、9的数字很感兴趣，在 1 到 40 中这样的数包括 1、2、9、10 至 32、39和 40，共 28 个，他们的和是 574,平方和是 14362。注意，平方和是指将每个数分别平方后求和。请问，在 1 到 2019 中，所有这样的数的平方和是多少？</strong></p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><blockquote><p>这道题看起来有点类似于题目一，也是对数字位数的特殊判断，但是本题需要我们判断的条件有点多，我们采用另外一种思路来操作，即我们将数字转换成字符串类型，再采用范围for语句对字符串的每个字符进行遍历，符合条件的我们就标记为true(1)，如果不符合条件我们就标记为false(0)。然后我们再对符合条件的数据进行平方和处理即可。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">long</span> <span class="token keyword">long</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化总平方和的变量sum，这里必须是long long 类型的，因为long long类型的数据范围是[-2^36,2^63-1],如果采用int类型，结果将溢出。</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">2019</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>  string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将数据i转换成字符串类型赋值给s</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> j<span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//采用范围for语句，对字符串s内的字符进行逐个遍历</span>      <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token string">'2'</span><span class="token operator">||</span>j<span class="token operator">==</span><span class="token string">'0'</span><span class="token operator">||</span>j<span class="token operator">==</span><span class="token string">'1'</span><span class="token operator">||</span>j<span class="token operator">==</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断是否有字符满足条件</span>        <span class="token punctuation">{</span>            sum<span class="token operator">+</span><span class="token operator">=</span><span class="token function">pow</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//若满足条件则直接计入总平方和的计数</span>           <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有一个字符满足条件了，说明该数字已经被判断好了，无需对剩余字符进行判断了，可以直接退出循环了</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>         <span class="token punctuation">}</span>   cout<span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出总的平方和</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="ti-mu">题目③</span><a href="#ti-mu" class="header-anchor">#</a></h2><blockquote><p><strong>题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。给定数列 1,1,1,3,5,9,17,⋯从第 4 项开始，每项都是前 3 项的和。求第 20190324 项的最后 4 位数字</strong></p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><blockquote><p>这道题的核心问题其实就对数据过大的处理，其实解决方案和第一题是一模一样的，题目需要你求最后四位数字，那我们就通过取余去保留最后四位数字，又因为根据加法原则，最后四位数的相加和其余位上的数没有直接关联，所有我们直接通过取余去缩小数据的值，在不影响所求结果的情况下继续使数据以较小的值进行相加。这样就可以完美解决本题了</p></blockquote><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化最开始的前三位数</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">20190324</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从第四位开始变量，遍历过程是a，b，c每次整体向后移一位</span>   <span class="token punctuation">{</span> temp<span class="token operator">=</span>c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//c代表最新的要更新的那个值，由于最新的那个值是前三位的值之和，平移的同时c的原数据不应被覆盖，所以我们拿一个临时变量temp用来存储c变量的原数据</span>     c<span class="token operator">=</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10000</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把最新的值赋值给c，整除10000是为了缩小数据的值，保留最后四位</span>     a<span class="token operator">=</span>b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将a数据向后平移一位，相当于把b的值赋给a</span>     b<span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b数据也要向后平移一位，相当于要把c的原数据赋值给b</span>   <span class="token punctuation">}</span>   cout<span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//c是最新的那个所求值，输出c即可</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h2><blockquote><p><strong>这第一题和第二题其实都存在对数据位数上的条件判断，对此我们可以有两种处理方案。①：灵活运用整除和取余，来去除数据的位数或者取出指定位数，以此来解决位数的条件判断问题。②：我们可以将数字直接转换成字符串类型，然后应用范围for循环依次对字符串的各个位数进行条件判断。还有这两道题还有一个烦人的点就是数据溢出问题，无论是题目一的乘积还是题目二的求总平方和，它们的结果的数据都会很大，这时候呢，我们要么采用题目一的分而治方式：先将明显存在的0计数完，然后去除计数完的0，然后运用乘法原则，发现数据的有些位数其实根本影响不到本题的求解，于是直接利用取余运算，将冗余部分的位数去除。或者采用第二题的方式，直接将计数变量的类型定位 long long 类型以支持数据的正常输出。第三道题核心就是保留最后四位数以减少数据的溢出的可能性，原理其实和第一题差不多。</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯2020年省赛填空题(七段码)</title>
      <link href="/2023/08/21/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E5%B9%B4%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98-%E4%B8%83%E6%AE%B5%E7%A0%81/"/>
      <url>/2023/08/21/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E5%B9%B4%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98-%E4%B8%83%E6%AE%B5%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1><span id="lan-qiao-bei-qi-duan-ma-2020-nian-sheng-sai">蓝桥杯：七段码（2020 年省赛）</span><a href="#lan-qiao-bei-qi-duan-ma-2020-nian-sheng-sai" class="header-anchor">#</a></h1><p>小蓝要用七段码数码管来表示一种特殊的文字。</p><p><img src="https://img1.imgtp.com/2023/08/21/6lAHTPLZ.jpg"></p><p> 七段码上图给出了七段码数码管的一个图示，数码管中一共有7 段可以发光的二极管，<br> 分别标记为a, b, c, d, e, f, g。小蓝要选择一部分二极管（至少要有一个）发光来表达字符。<br> 在设计字符的表达时，要求所有发光的二极管是连成一片的。<br>例如：b 发光，其他二极管不发光可以用来表达一种字符。<br>例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上一行的方案可以用来表示不同的字符，尽管看上去比较相似。<br>例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。<br>例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。<br>请问，小蓝可以用七段码数码管表达多少种不同的字符？</p><h2><span id="wen-ti-fen-xi">问题分析</span><a href="#wen-ti-fen-xi" class="header-anchor">#</a></h2><h3><span id="wen-ti-jian-hua">问题简化</span><a href="#wen-ti-jian-hua" class="header-anchor">#</a></h3><blockquote><p><strong>根据题意所述，它需要我们求出能二极管能表达出的字符种类有多少个。那我们很容易就能想到这道题完全可以转换成求点到任意点的路径数量有多少的题目。但是由于a-&gt;b显示的图形和b-&gt;a显示出来的其实是一样的，所以最后的答案应该是路径的总数量/2</strong></p></blockquote><h3><span id="jie-jue-wen-ti">解决问题</span><a href="#jie-jue-wen-ti" class="header-anchor">#</a></h3><h4><span id="wen-ti-ti-chu">问题提出</span><a href="#wen-ti-ti-chu" class="header-anchor">#</a></h4><blockquote><p><strong>既然是搜索路径的题目，我们很容易就可以想到dfs深度优先遍历搜索算法，也就是选择任意一个点作为起始点，访问过的结点我们全部标记为True，随后不断进入子结点，直到碰到退出条件。dfs算法会对每个访问过的路径进行标记，标记过的结点则无法再次访问，这就导致了如果一个点到另外一个结点有两条路，dfs就只能优先遍历程序设置的那条路，另外一条路则不会被计算在内（如下演示图）</strong></p></blockquote><p><strong>正常的dfs遍历:</strong><br><img src="https://img1.imgtp.com/2023/08/21/DdRZJJeg.gif" alt="dfs"><br><strong>本题需要的遍历:</strong><br><img src="https://img1.imgtp.com/2023/08/21/bVTN4XtD.gif" alt="遍历"></p><h4><span id="jie-jue-fang-an">解决方案</span><a href="#jie-jue-fang-an" class="header-anchor">#</a></h4><blockquote><p>如上两个演示图，我们可以看到问题所在是dfs遇到返回条件返回的时候，遍历过的结点依旧被标记，这就导致了从B-&gt;D-E的路线，dfs其实是无法实现计算在内的。既然是标记结点的问题，那我们只要每一次遇到返回条件返回结点的时候把已经返回了的结点标记重置为False（未访问状态）不就可以完美解决本题了嘛，这就是基于DFS改编的<strong>回溯算法</strong>的雏形</p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><h2><span id="he-xin-dai-ma-jiang-jie">核心代码讲解</span><a href="#he-xin-dai-ma-jiang-jie" class="header-anchor">#</a></h2><pre class="line-numbers language-xml"><code class="language-xml">void Backtracking(int i, int visit[], int *count) {    for (int j = 0; j &lt; 7; j++) /*依次从a（0），b（1），c（2），d(3)，e(4)，f(5)，g(6)这七个二极管分别作为出发点进行遍历*/    {        if (graph[i][j] == 1 &amp;&amp; visit[j] == 0) //如果两个结点之间有连接且要访问的那个结点没有被访问过则满足条件        {            visit[j]=1;//提前标记我们要进入的那个结点已经被我们访问了            dfs(j, visit, count);//进入新结点，从新结点的基础上继续搜索路径            ( *count)++;//回退的时候进行计数            visit[j] = 0;//将已经回退的那个结点访问标记重置为0                            }                                    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>这里有一个细节要注意：我们的count初始化进来是值是1，因为存在一种情况：如果结点走到无路可走，程序其实是从if判断语句那里直接退出的，根本就没有进入if语句内部。也就是说当前的路径没有被计数进去，所以我们要在初始化count的时候就让它天然的就是以1为起步。</strong></p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int graph[7][7] = {//如果两个相邻的结点有连接，则标记为1，例如：(0,1)，0->1有连接，那么我们的graph[0][1]=1，同时1->0也是有连接的，那我们的graph[1][0]=1        {1, 1, 0, 0, 0, 1, 0},        {1, 1, 1, 0, 0, 0, 1},        {0, 1, 1, 1, 0, 0, 1},        {0, 0, 1, 1, 1, 0, 0},        {0, 0, 0, 1, 1, 1, 1},        {1, 0, 0, 0, 1, 1, 1},        {0, 1, 1, 0, 1, 1, 1}};void Backtracking(int i, int visit[], int *count) {    for (int j = 0; j < 7; j++) {        if (graph[i][j] == 1 && visit[j] == 0) {            visit[j]=1;            dfs(j, visit, count);            ( *count)++;            visit[j] = 0;                            }                                    }}int main() {    int count = 1;//将count变量用来计数    int visit[7] = {0};//初始化访问标记数组    Backtracking(0, visit, &count);//调用回溯函数    cout << count / 2 << endl;//输出种类数    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start: 创建一个7×7的数组，用来存储结点的连接情况op=&gt;operation: 自定义函数Backtracking用来遍历结点op1=&gt;operation: 在Backtracking函数中改编DFS算法使之成为回溯算法，且符合条件后每次回退都进行路径数量的计数op2=&gt;operation: 因为我们要求的是路径所显示的图形，比如从a-&gt;b显示的图形和b-&gt;a显示出来的其实是一样的，所以最后我们要求的图形种类应该是总路径/2end=&gt;end: 输出总路径/2st-&gt;op-&gt;op1-&gt;op2-&gt;end</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的简单理解</title>
      <link href="/2023/08/20/%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
      <url>/2023/08/20/%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2><span id="tu">图</span><a href="#tu" class="header-anchor">#</a></h2><h3><span id="li-yong-shu-zu-gou-jian-tu">利用数组构建图</span><a href="#li-yong-shu-zu-gou-jian-tu" class="header-anchor">#</a></h3><h4><span id="wu-xiang-tu"><strong>无向图</strong></span><a href="#wu-xiang-tu" class="header-anchor">#</a></h4><pre class="line-numbers language-xml"><code class="language-xml">#include &lt;bits/stdc++.h>using  namespace  std;typedef char VertexType;typedef int EdgeType;#define MAXVER 100#define INFINITY 65532typedef struct{    VertexType vexs[MAXVER];    EdgeType arc[MAXVER][MAXVER];    int numNodes,numEdges;}MGraph;void CreatMGraph(MGraph *G){    int i,j,k,w;    cout&lt;&lt;"输入顶点数和边数:"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>    <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>G->numNodes>>G->numEdges;  //录入顶点和边数量的信息    cout&lt;&lt;"请输入顶点的具体的值"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>    <span class="token attr-name">for(i</span><span class="token attr-value"><span class="token punctuation">=</span>0;i&lt;G-</span><span class="token punctuation">></span></span>numNodes;i++)    {  cin>>G->vexs[i];    }    for(i=0;i<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes;i++)    {  for(j=1;j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes;j++)        {           G->arc[i][j]=INFINITY;        }      }    for(k=0;k<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes;k++)    {  cout&lt;&lt;"输入边(vi,vj)的下标i，j，以及权重w"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>        <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>i>>j>>w;        G->arc[i][j]=w;//输入权重值        G->arc[j][i]=w;    }//无向图的矩阵对称}int main(){    MGraph G1;//创建一个空的G1无向图变量     CreatMGraph(&amp;G1);//调用函数初始化G1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="li-yong-lian-biao-lai-gou-zao-tu">利用链表来构造图</span><a href="#li-yong-lian-biao-lai-gou-zao-tu" class="header-anchor">#</a></h3><h4><span id="wu-xiang-tu"><strong>无向图</strong></span><a href="#wu-xiang-tu" class="header-anchor">#</a></h4><pre class="line-numbers language-xml"><code class="language-xml">#include &lt;bits/stdc++.h>using  namespace  std;typedef char VertexType;typedef int EdgeType;#define MAXVEX 100#define INFINITY 65532typedef struct EdgeNode{ int adjvex;存储当前结点的位置    EdgeType weight;存储权值    struct EdgeNode *Next; 存储下一个指向的结点}EdgeNode; //构造出边表结点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码具象化：<br><img src="https://img1.imgtp.com/2023/08/20/PblUz2Ru.jpg" alt="构造出边表结点图"></p></blockquote><pre class="line-numbers language-xml"><code class="language-xml">typedef struct VertexNode{    VertexType data;//存储顶点的数值    EdgeNode *firstedge;//存储顶点指向的下一个结点}VertexNode,AdjList[MAXVEX];//构造出顶点列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码具象化：<br><img src="https://img1.imgtp.com/2023/08/20/oNvo9jJN.jpg" alt="构造出顶点列表图"></p></blockquote><pre class="line-numbers language-xml"><code class="language-xml">typedef struct{    AdjList adjList;    int numNodes,numEdges;}GraphAdjlist;void CreatMGraph(GraphAdjlist *G){    int i,j,k,w;    EdgeNode *e;//定义一个边表    cout&lt;&lt;"输入顶点数和边数:"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>    <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>G->numNodes>>G->numEdges;    for (int i=0; i<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes ; ++i) {      cin>>G->adjList[i].data;//初始化顶点表的data数值      G->adjList[i].firstedge=NULL;//初始化顶点表的firstedge的数值    }    for(k=0;k<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numEdges;k++)//    {        cout&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>"输入边（vi，vj）上的顶点序号";</span>        <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>i>>j;        e=(EdgeNode *)malloc(sizeof(EdgeNode));//申请边表类型的一个临时内存        e->adjvex=j;//把j输入到边表结点的adjvex上，表达当前j的位置        e->Next=G->adjList[i].firstedge;//采用头插法将位置为j的边表结点插入到头节点i对应的下一个结点。         G->adjList[i].firstedge=e;        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码具象化：<br><img src="https://img1.imgtp.com/2023/08/20/XTAqW8FZ.jpg" alt="头插法"></p></blockquote><p><strong>因为是无向图，所以正反两面都要配置，上面是i-&gt;j的配置,下面的代码是j-&gt;i的配置</strong></p><pre class="line-numbers language-xml"><code class="language-xml">        e=(EdgeNode *)malloc(sizeof(EdgeNode));        e->adjvex=i;        e->Next=G->adjList[j].firstedge;        G->adjList[j].firstedge=e;            }        free(e);//释放申请malloc的动态内存}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5><span id="wan-zheng-dai-ma">完整代码</span><a href="#wan-zheng-dai-ma" class="header-anchor">#</a></h5><pre class="line-numbers language-xml"><code class="language-xml">#include &lt;bits/stdc++.h>using  namespace  std;typedef char VertexType;typedef int EdgeType;#define MAXVEX 100#define INFINITY 65532typedef struct EdgeNode{ int adjvex;存储当前结点的位置    EdgeType weight;存储权值    struct EdgeNode *Next; 存储下一个指向的结点}EdgeNode; //构造出边表结点typedef struct VertexNode{    VertexType data;//存储顶点的数值    EdgeNode *firstedge;//存储顶点指向的下一个结点}VertexNode,AdjList[MAXVEX];//构造出顶点列表typedef struct{    AdjList adjList;    int numNodes,numEdges;}GraphAdjlist;void CreatMGraph(GraphAdjlist *G){    int i,j,k,w;    EdgeNode *e;//定义一个边表    cout&lt;&lt;"输入顶点数和边数:"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>    <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>G->numNodes>>G->numEdges;    for (int i=0; i<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes ; ++i) {      cin>>G->adjList[i].data;//初始化顶点表的data数值      G->adjList[i].firstedge=NULL;//初始化顶点表的firstedge的数值    }    for(k=0;k<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numEdges;k++)//    {        cout&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>"输入边（vi，vj）上的顶点序号";</span>        <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>i>>j;        e=(EdgeNode *)malloc(sizeof(EdgeNode));//申请边表类型的一个临时内存        e->adjvex=j;//把j输入到边表结点的adjvex上，表达当前j的位置        e->Next=G->adjList[i].firstedge;//采用头插法将位置为j的边表结点插入到头节点i对应的下一个结点。          G->adjList[i].firstedge=e;        e=(EdgeNode *)malloc(sizeof(EdgeNode));        e->adjvex=i;        e->Next=G->adjList[j].firstedge;        G->adjList[j].firstedge=e;             }        free(e);//释放申请malloc的动态内存}int main(){GraphAdjlist *G1; CreatMGraph(G1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯2017年省赛填空题（统计出迷宫的人数）</title>
      <link href="/2023/08/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%88%E8%BF%B7%E5%AE%AB%EF%BC%89/"/>
      <url>/2023/08/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%88%E8%BF%B7%E5%AE%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2><span id="lan-qiao-bei-2017-nian-sheng-sai-tian-kong-ti-mi-gong">蓝桥杯2017年省赛填空题：迷宫</span><a href="#lan-qiao-bei-2017-nian-sheng-sai-tian-kong-ti-mi-gong" class="header-anchor">#</a></h2><blockquote><p>题目描述:<br>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。<br>X 星球的一处迷宫游乐场建在某个小山坡上。它是由 10×10 相互连通的小房间组成的。<br>房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：</p><ul><li>L 表示走到左边的房间，</li><li>R 表示走到右边的房间，</li><li>U 表示走到上坡方向的房间，</li><li>D 表示走到下坡方向的房间。</li></ul></blockquote><blockquote><p>X 星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！<br>开始的时候，直升机把 100 名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。<br>迷宫地图如下：<br>UDDLUULRUL<br>UURLLLRRRU<br>RRUURLDLRD<br>RUDDDDUUUU<br>URUDLLRRUU<br>DURLRLDLRL<br>ULLURLLRDU<br>RDLULLRDDD<br>UUDDUDUDLL<br>ULRDLUURRR<br>请你计算一下，最后，有多少玩家会走出迷宫，而不是在里边兜圈子？<br>如果你还没明白游戏规则，可以参看下面一个简化的 4x4 迷宫的解说图：<br><img src="https://img1.imgtp.com/2023/08/17/FEuRHtiB.jpg" alt="img"></p></blockquote><hr><h2><span id="zhi-shi-dian-chu-bei">知识点储备</span><a href="#zhi-shi-dian-chu-bei" class="header-anchor">#</a></h2><ul><li><strong>DFS深度优先遍历算法</strong></li><li><strong>树的前序遍历</strong></li><li><strong>递归</strong></li></ul><h3><span id="zhi-shi-dian-fu-xi">知识点复习</span><a href="#zhi-shi-dian-fu-xi" class="header-anchor">#</a></h3><h3><span id="shu-de-qian-xu-bian-li"><strong>树的前序遍历</strong>：</span><a href="#shu-de-qian-xu-bian-li" class="header-anchor">#</a></h3><h4><span id="kuai-su-gai-shu">快速概述</span><a href="#kuai-su-gai-shu" class="header-anchor">#</a></h4><blockquote><p>假如我们有如图所示的数据：<br><img src="https://img1.imgtp.com/2023/08/17/NWR3sFPX.jpg" alt="img"><br><strong>前置规定</strong>：我们规定把A作为根结点，且优先遍历左结点，直到左结点没有为止，然后再去走右结点，左右结点都遍历过了之后再回传到上一个父结点<br><strong>正式操作</strong>：我们从A结点开始出发，发现B和E结点两条路可以走，因为我们前置规定优先遍历左结点，所以走B结点，走到B结点发现左边没有结点可以走了，然后我们开始走B结点的右结点C，C结点之后按照同样的规定，我们依次遍历F、D 。走完D之后我们发现左右都没路了，我们开始回传到C结点、同样的F、D对结点于C来说是它的左右子结点， 我们已经遍历过了，于是C结点回传给B结点，同理B结点回传给A结点。对于A来说E结点还没遍历过，于是开始遍历E结点。E结点遍历之后按照同样的规则回传给A结点。至此，程序结束。</p></blockquote><hr><blockquote><p>文字描述看来很抽象，接下来我们直接放伪代码，来和文字结合理解一下。</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">struct Tree{  char data[2];//存储结点的名字    struct Tree *LeftNode;//存储结点左边的子节点    struct Tree *RightNode;//存储结点右边的子节点}*T;//创建树的结点T/*读入数据初始化结点T*/Void PreOrderTraverse(结点T){    if(T==NULL)  //如果该结点是空的，就执行return直接退出当前自定义函数         return;    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h4><blockquote><p>核心语句:</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>其实前序遍历的本质就是一个递归算法。前序遍历的第一句是 <strong>print(“%c”,T-&gt;data);</strong> 直接打印当前结点的名字，第二句<strong>PreOrderTraverse(T-&gt;LeftNode);</strong> 的意思是不断地进入左边的子结点，直到结点为空。同理第三句<strong>PreOrderTraverse(T-&gt;RightNode);<strong>的意思是承接第二句执行后的结点，去遍历这个结点的右边子节点。有就打印，没有（或者遍历过）就返回这个结点的父节点。</strong>结束标准：A结点的右边子节点全部遍历完毕，返回到A结点，则判定程序结束。</strong></p></blockquote><h3><span id="dfs-shen-du-you-xian-bian-li-suan-fa">DFS深度优先遍历算法</span><a href="#dfs-shen-du-you-xian-bian-li-suan-fa" class="header-anchor">#</a></h3><blockquote><p>了解了树的前序遍历之后呢，我们就来介绍我们的重头戏<strong>DFS深度优先遍历算法</strong></p><blockquote><p>在此之前，我想提出一个问题：假如你现在处于一个迷宫里面，里面有7个房间，你想要去碰碰运气找遍所有房间，那你该怎么做？</p></blockquote><blockquote><p>我觉得大部分人的第一反应就是从某个房间出发，然后不断一个一个找过去，已经走过的，我们就标记一下，直到又回到了出发的那个房间为止。</p><blockquote><p><strong>这种方式就是DFS深度优先遍历算法的雏形</strong></p></blockquote></blockquote></blockquote><h4><span id="kuai-su-gai-shu">快速概述</span><a href="#kuai-su-gai-shu" class="header-anchor">#</a></h4><blockquote><p>假如我们有如下的数据<br><img src="https://img1.imgtp.com/2023/08/17/v5n6Efb3.jpg" alt="img"><br><strong>前置规定</strong>：我们可以随机选择一个结点作为根结点，且优先遍历左结点，（<strong>同时每走一个结点，我们用变量 visit 标记一下，表明我们走过这个结点了。</strong>）</p><blockquote><p><strong>回退结点的规则</strong>：<strong>若结点被visit标记了或者左右结点都不存在</strong></p></blockquote></blockquote><blockquote><p><strong>正式操作</strong>：我们从A结点开始出发，发现B和E结点两条路可以走，因为我们前置规定优先遍历左结点，所以走B结点，B结点左边是C结点，于是我们来到了C结点，同理C结点的的左边是F，F的左节点是G，G的左节点是E，E的左节点是A结点，但是A是我们走过的结点，已经用visit标记了，于是我们从A返回到E结点，继续执行E结点剩余的程序，显然E结点没有右子结点了，于是我们退回G结点，按照同样的规律，最后我们将退回结点到A结点，至此，程序结束。</p></blockquote><blockquote><blockquote><p><strong>看到这里，有没有发现DFS深度优先遍历算法其实就是前序遍历算法的变式呀，只不过DFS深度遍历算法增加了变量visit用来标记已经变量过的结点，以此来提早退回遍历过的结点。</strong></p></blockquote></blockquote><h4><span id="dai-ma-shi-xian">代码实现</span><a href="#dai-ma-shi-xian" class="header-anchor">#</a></h4><pre class="line-numbers language-c++"><code class="language-c++">struct Tree{  char data[2];//存储结点的名字   int vist=0;//规定visit=0还没有被遍历，visit=1，则已经被遍历    struct Tree *LeftNode;//存储结点左边的子节点    struct Tree *RightNode;//存储结点右边的子节点}*T;//创建树的结点T/*读入数据初始化结点T*/Void PreOrderTraverse(结点T){    if(T==NULL)  //如果该结点是空的，就执行return直接退出当前自定义函数         return;     if (visit==1)//如果当前结点已经被访问过了，那么直接退出当前自定义函数，         return ;                                        // 返回上一个结点        T->visit=1; //当前结点已经被遍历    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5><span id="xi-jie-jie-shi">细节解释</span><a href="#xi-jie-jie-shi" class="header-anchor">#</a></h5><p><img src="https://img1.imgtp.com/2023/08/17/v5n6Efb3.jpg" alt="img"></p><blockquote><p>假如我们已经从E执行到了A结点，此时我们发现A是已经被visit标记了的,源代码对应：</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">if (visit==1)//如果当前结点已经被访问过了，那么直接退出当前自定义函数，    return;                      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><blockquote><p>此时我们从A回退到E结点来执行E结点的剩余代码：<br><strong>PreOrderTraverse(T-&gt;RightNode);//进入结点右边的子节点</strong><br><strong>因为是回退结点，而不是对该结点的重头开始执行，所以从A结点回退到E结点的时候，对于E结点来说：   PreOrderTraverse(T-&gt;LeftNode);已经执行完毕，所以我们只要执行它的下一行PreOrderTraverse(T-&gt;RightNode);即可。</strong></p></blockquote><hr><h2><span id="ti-mu-jiang-jie">题目讲解</span><a href="#ti-mu-jiang-jie" class="header-anchor">#</a></h2><blockquote><p>有了上面的知识储备之后， 我们回归题目本身</p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-xml"><code class="language-xml">//#include &lt;bits/stdc++.h>#include<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iostream</span><span class="token punctuation">></span></span>#include<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string.h</span><span class="token punctuation">></span></span>using  namespace  std;char Maps[10][10]={        'U','D','D','L','U','U','L','R','U','L',        'U','U','R','L','L','L','R','R','R','U',        'R','R','U','U','R','L','D','L','R','D',        'R','U','D','D','D','D','U','U','U','U',        'U','R','U','D','L','L','R','R','U','U',        'D','U','R','L','R','L','D','L','R','L',        'U','L','L','U','R','L','L','R','D','U',        'R','D','L','U','L','L','R','D','D','D',        'U','U','D','D','U','D','U','D','L','L',        'U','L','R','D','L','U','U','R','R','R'};//初始化地图int visit[10][10];//创建visit变量void dfs(int i,int j,int*count) {    if (i&lt;0||i>9||j&lt;0||j>9)    {        (*count)++;//人数+1。count我们传入的是指针，这样可以实现自定义外函数的count也在同步变化        return ;//过程中没有一次碰到走过的路，并且最后来到了地图边缘，此时我们可以判定出迷宫了    }   else    {        if(visit[i][j])        {  return ;        }//假如走的时候发现这条路是走过的，说明是鬼打墙。就不需要继续走下去了，可以直接提早结束            visit[i][j]=1;//走过的块我们标记为1说明已经走过了            if (Maps[i][j]=='U')                dfs(i-1,j,count);//当前方块是U的话就行数减一,向上走            else if (Maps[i][j]=='D')//当前方块是D的话行数加一，向下走                dfs(i+1,j,count);            else if(Maps[i][j]=='L')//当前方块是L的话列数减一，向左走                dfs(i,j-1,count);            else if (Maps[i][j]=='R')//当前方块是L的话列数加一，向右走                dfs(i,j+1,count);    }}int main(){ int count=0;//初始化能够走出迷宫的人数    for(int i=0;i&lt;10;i++)    {        for(int j=0;j&lt;10;j++)        {            memset(visit, 0, sizeof(visit));//memset是用来将visit里面的数组的值全部初始化为0            dfs(i,j,&amp;count);        }//通过两个for循环嵌套去逐个对每个方格进行dfs遍历搜寻判断    } cout&lt;&lt;count&lt;&lt;endl;//输出count即可}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路借鉴：<a href="https://blog.csdn.net/SakuraZhangrx/article/details/106922392">https://blog.csdn.net/SakuraZhangrx/article/details/106922392</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start:  用数组初始化10×10的地图op=&gt;operation:  命名一个自定义函数为dfs()，其中dfs中正常能够出地图的，我们采用count变量+1来统计op1=&gt;operation: 主程序中我们使用嵌套for循环依次对地图的每一块依次变量e=&gt;end: 输出countst-&gt;op-&gt;op1-&gt;e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构笔记(一)：算法复杂度（基础篇）</title>
      <link href="/2023/08/15/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC(%E5%9F%BA%E7%A1%80%E7%AF%87)/"/>
      <url>/2023/08/15/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC(%E5%9F%BA%E7%A1%80%E7%AF%87)/</url>
      
        <content type="html"><![CDATA[<h2><span id="suan-fa-fu-za-du-fen-xi-jian-yao-gai-gua">算法复杂度分析简要概括</span><a href="#suan-fa-fu-za-du-fen-xi-jian-yao-gai-gua" class="header-anchor">#</a></h2><p><strong>算法复杂度</strong></p><ul><li><strong>时间复杂度</strong></li><li><strong>空间复杂度</strong></li></ul><hr><blockquote><p>时间复杂度的简单理解：进行算法分析时，我们假设每行的每次执行时间是t，n是某个循环的中止值。随后我们统计下所有行的代码执行次数，记作f(n)，那么我们整个的程序的总的执行时间T为:f(n)×t。根据T函数我们可以看出T与f(n)成正比。此时我们就可以根据f(n)的函数增长率去估算时间复杂度，<strong>这里我们需要注意的是,我们只关注函数的增长率，而不关注n究竟是多大。</strong></p></blockquote><h2><span id="tui-dao-fang-fa-jie-shao">推导方法介绍</span><a href="#tui-dao-fang-fa-jie-shao" class="header-anchor">#</a></h2><h3><span id="tui-dao-liu-cheng">推导流程</span><a href="#tui-dao-liu-cheng" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><p><strong>核心：只关注推导出来的函数的最高阶项的阶数</strong></p><h3><span id="ju-ge-li-zi">举个栗子</span><a href="#ju-ge-li-zi" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行1次</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//执行n+1次</span><span class="token punctuation">{</span> count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行n次</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>根据注释可推出总次数的函数式f(n)=1+n+1+n=2n+2</p></blockquote><p><strong>化简原则:</strong></p><ul><li><strong>①函数如果是一个常数，不管多大，全用1代替，记作O(1)</strong></li><li><strong>②函数只保留最高阶项，若最高阶项的系数是常数，则统一用1代替，否则保留系数</strong></li></ul><blockquote><p>本题根据化简原则②可以将f(n)=2n+2，记作f(n)=n,即O(n),这就是我们这段程序的时间复杂度</p></blockquote><h3><span id="yi-wen">疑问</span><a href="#yi-wen" class="header-anchor">#</a></h3><blockquote><p>Q1:刚学的时候，关于这道例子我是有一个问题的，那就是n明明在一开始的时候就定义了n=100。那n不应该是一个常数吗？我的函数式不应该写成1+100+1+100=202吗？时间复杂度应该是O(1)而不是O(n)呀</p></blockquote><hr><blockquote><p>A1：我认为时间复杂度的理解应该是基于过程而言的，而不是基于结果的。基于结果，整个n肯定是一个有结果的值，我们可以看作它是一个基于常数时间复杂度的算法。但是当我们谈论时间复杂度时，我们通常会假设 n 是一个变量，它可以取任意值。这样我们就可以分析算法的运行时间随着输入数据规模的增长而增长的速度。</p><p>回到上面的问题，f(n)=2n+2,我们说n=100的时候，我们从结果的角度看，的确它可以叫做O(1)的时间复杂度，但是n是可以变化的，n可以是1，2，3……10000等等。也就是说我们是不只研究单单n=100这一个例子。我们研究的是一整个关于f(n)函数的增长变化情况的全局，本题的例子中这个f(n)的变化明显是类似于线性的变化，于是我们根据化简原则，可以得出时间复杂度是O(n),而不是O(1)<br><img src="https://img1.imgtp.com/2023/08/16/2LRqrNWv.png" alt="img"></p></blockquote><h3><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h3><blockquote><p><strong>算法的复杂度是基于过程的而非单一的结果,根据循环的规律去写出次数对应的函数是关键，因为我们研究的是函数的整体变化速率。最后，根据化简原则，我们将函数化简之后得到的表达式就是我们需要的时间复杂度O()</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start: 列出各行代码的执行次数op=&gt;operation: 统计总次数并且写成函数式子op1=&gt;operation: 对函数式子进行化简处理e=&gt;end: 分析结果st-&gt;op-&gt;op1-&gt;e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2023/08/14/%E5%89%8D%E8%A8%80/"/>
      <url>/2023/08/14/%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>说实话，这是我第一次想着搭建一个个人博客来创作，事情的起因是前天学校老师给了我一套蓝桥杯的算法资料，那套资料对于算法的分类写的非常清晰，一目了然。于是我当时二话不说就写了一下午。不得不说，如果算法如果不难的话还是很有趣的<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。哈哈哈。那种感觉就像成功就在你眼前，但是你一抓他就往前跑。不断刺激你去抓到他。这种感觉是又爱又恨。那天写了几节之后，我开始问我自己，学习这些算法，如果我只是单单的像流水线一样过了一遍，真的有效吗？有过之前经历过无数次现实毒打的经历的经验之后，我明确告诉我自己，这是不可能的，学习的本质应该是不断的重复，以来对抗遗忘。所以顺其自然的我就想着搭建一个个人博客，来主要作为记录我个人的笔记平台，用来总结我写过的每一道算法题，以及背后对原理的思考。</p><p>比起传统的纸质笔记本，我认为电子化笔记的可以不受地点和时间的制约，这是我选择它的一大原因。同时呢，如果有能力的话，我也想分享高中的信息技术的内容。因为曾经我最迷茫的时候，是很多拥有公众号的技术老师以及博主分享了很多珍贵的资料，让我在黑暗中能够看见光亮。高中信息技术这门课改革之后加入了python以及数据结构。难度直线飙升，这对本就缺少资源的普通高中的学生更是雪上加霜。我深深的体会过这一点，所以我也想分享这些内容，发一点光，帮助曾经像我一样迷茫的同学们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
