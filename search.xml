<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>蓝桥杯小题杂记</title>
      <link href="/2023/08/22/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E9%A2%98%E6%9D%82%E8%AE%B0/"/>
      <url>/2023/08/22/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B0%8F%E9%A2%98%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1><span id="lan-qiao-bei-xiao-ti-za-ji">蓝桥杯小题杂记</span><a href="#lan-qiao-bei-xiao-ti-za-ji" class="header-anchor">#</a></h1><h2><span id="ti-mu">题目①</span><a href="#ti-mu" class="header-anchor">#</a></h2><h3><span id="ti-mu-miao-shu">题目描述</span><a href="#ti-mu-miao-shu" class="header-anchor">#</a></h3><blockquote><p>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。<br>如下的 10行数据，每行有 10 个整数，请你求出它们的乘积的末尾有多少个零？</p><p><strong>5650 4542 3554 473 946 4114 3871 9073 90 4329<br>2758 7949 6113 5659 5245 7432 3051 4434 6704 3594<br>9937 1173 6866 3397 4759 7557 3070 2287 1453 9899<br>1486 5722 3135 1170 4014 5510 5120 729 2880 9019<br>2049 698 4582 4346 4427 646 9742 7340 1230 7683<br>5693 7015 6887 7381 4172 4341 2909 2027 7355 5649<br>6701 6645 1671 5978 2704 9926 295 3125 3878 6785<br>2066 4247 4800 1578 6652 4616 1113 6205 3264 2915<br>3966 5291 2904 1285 2193 1428 2265 8730 9436 7074<br>689 5510 8243 6114 337 4096 8199 7313 3685 211</strong></p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><blockquote><p>题目说要求这100个数据的乘积有多少个零，如果我们直接将这些数据相乘，那将会是一个天文数字，肯定会超出数据类型的最大值。那怎么办？一种显而易见的方式是：分而治。首先：先将摆在明面上的数据有零的先提早进行计数，计数完之后将数据记完数的含零部分进行剔除。所有数据按照这种思路执行，直到遍历完成。 其次：根据两数相乘的法则，同时图中数据最大的位数是4位数，我们还可以在去除完多余的0数据之后只保留原数据（被乘数）的最后四位。因为乘数最大是四位数，与被乘数的有效乘积其实只有四位，所以我们完全可以去除原数据（被乘数）的冗余位数。至此我们就实现了在保证数据不超出类型的最大值的情况下完成了对总乘积值的零数据的计数。</p></blockquote><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化全局计数变量count</span><span class="token keyword">int</span> <span class="token function">DivideZero</span><span class="token punctuation">(</span><span class="token keyword">int</span>  i<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">/</span><span class="token number">10</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//遍历数据的每一个位数</span>    <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">10</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//如果该位是0，则计数+1</span>    <span class="token punctuation">{</span>      count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token comment" spellcheck="true">//如果该位数不是0，则直接返回这个数的值</span>     <span class="token keyword">return</span> i<span class="token punctuation">;</span>        i<span class="token operator">=</span>i<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除判断完的位数</span>    <span class="token punctuation">}</span>      <span class="token keyword">return</span>  i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果这个位数除了最高位之外都是0，只剩该最高位，则返回这个最高位的值</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">103</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>   <span class="token number">5650</span><span class="token punctuation">,</span><span class="token number">4542</span><span class="token punctuation">,</span><span class="token number">3554</span><span class="token punctuation">,</span><span class="token number">473</span><span class="token punctuation">,</span><span class="token number">946</span><span class="token punctuation">,</span><span class="token number">4114</span><span class="token punctuation">,</span><span class="token number">3871</span><span class="token punctuation">,</span><span class="token number">9073</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">4329</span><span class="token punctuation">,</span>   <span class="token number">2758</span><span class="token punctuation">,</span><span class="token number">7949</span><span class="token punctuation">,</span><span class="token number">6113</span><span class="token punctuation">,</span><span class="token number">5659</span><span class="token punctuation">,</span><span class="token number">5245</span><span class="token punctuation">,</span><span class="token number">7432</span><span class="token punctuation">,</span><span class="token number">3051</span><span class="token punctuation">,</span><span class="token number">4434</span><span class="token punctuation">,</span><span class="token number">6704</span><span class="token punctuation">,</span><span class="token number">3594</span><span class="token punctuation">,</span>   <span class="token number">9937</span><span class="token punctuation">,</span><span class="token number">1173</span><span class="token punctuation">,</span><span class="token number">6866</span><span class="token punctuation">,</span><span class="token number">3397</span><span class="token punctuation">,</span><span class="token number">4759</span><span class="token punctuation">,</span><span class="token number">7557</span><span class="token punctuation">,</span><span class="token number">3070</span><span class="token punctuation">,</span><span class="token number">2287</span><span class="token punctuation">,</span><span class="token number">1453</span><span class="token punctuation">,</span><span class="token number">9899</span><span class="token punctuation">,</span>   <span class="token number">1486</span><span class="token punctuation">,</span><span class="token number">5722</span><span class="token punctuation">,</span><span class="token number">3135</span><span class="token punctuation">,</span><span class="token number">1170</span><span class="token punctuation">,</span><span class="token number">4014</span><span class="token punctuation">,</span><span class="token number">5510</span><span class="token punctuation">,</span><span class="token number">5120</span><span class="token punctuation">,</span><span class="token number">729</span><span class="token punctuation">,</span><span class="token number">2880</span><span class="token punctuation">,</span><span class="token number">9019</span><span class="token punctuation">,</span>   <span class="token number">2049</span><span class="token punctuation">,</span><span class="token number">698</span><span class="token punctuation">,</span><span class="token number">4582</span><span class="token punctuation">,</span><span class="token number">4346</span><span class="token punctuation">,</span><span class="token number">4427</span><span class="token punctuation">,</span><span class="token number">646</span><span class="token punctuation">,</span><span class="token number">9742</span><span class="token punctuation">,</span><span class="token number">7340</span><span class="token punctuation">,</span><span class="token number">1230</span><span class="token punctuation">,</span><span class="token number">7683</span><span class="token punctuation">,</span>   <span class="token number">5693</span><span class="token punctuation">,</span><span class="token number">7015</span><span class="token punctuation">,</span><span class="token number">6887</span><span class="token punctuation">,</span><span class="token number">7381</span><span class="token punctuation">,</span><span class="token number">4172</span><span class="token punctuation">,</span><span class="token number">4341</span><span class="token punctuation">,</span><span class="token number">2909</span><span class="token punctuation">,</span><span class="token number">2027</span><span class="token punctuation">,</span><span class="token number">7355</span><span class="token punctuation">,</span><span class="token number">5649</span><span class="token punctuation">,</span>   <span class="token number">6701</span><span class="token punctuation">,</span><span class="token number">6645</span><span class="token punctuation">,</span><span class="token number">1671</span><span class="token punctuation">,</span><span class="token number">5978</span><span class="token punctuation">,</span><span class="token number">2704</span><span class="token punctuation">,</span><span class="token number">9926</span><span class="token punctuation">,</span><span class="token number">295</span><span class="token punctuation">,</span><span class="token number">3125</span><span class="token punctuation">,</span><span class="token number">3878</span><span class="token punctuation">,</span><span class="token number">6785</span><span class="token punctuation">,</span>   <span class="token number">2066</span><span class="token punctuation">,</span><span class="token number">4247</span><span class="token punctuation">,</span><span class="token number">4800</span><span class="token punctuation">,</span><span class="token number">1578</span><span class="token punctuation">,</span><span class="token number">6652</span><span class="token punctuation">,</span><span class="token number">4616</span><span class="token punctuation">,</span><span class="token number">1113</span><span class="token punctuation">,</span><span class="token number">6205</span><span class="token punctuation">,</span><span class="token number">3264</span><span class="token punctuation">,</span><span class="token number">2915</span><span class="token punctuation">,</span>   <span class="token number">3966</span><span class="token punctuation">,</span><span class="token number">5291</span><span class="token punctuation">,</span><span class="token number">2904</span><span class="token punctuation">,</span><span class="token number">1285</span><span class="token punctuation">,</span><span class="token number">2193</span><span class="token punctuation">,</span><span class="token number">1428</span><span class="token punctuation">,</span><span class="token number">2265</span><span class="token punctuation">,</span><span class="token number">8730</span><span class="token punctuation">,</span><span class="token number">9436</span><span class="token punctuation">,</span><span class="token number">7074</span><span class="token punctuation">,</span>   <span class="token number">689</span><span class="token punctuation">,</span><span class="token number">5510</span><span class="token punctuation">,</span><span class="token number">8243</span><span class="token punctuation">,</span><span class="token number">6114</span><span class="token punctuation">,</span><span class="token number">337</span><span class="token punctuation">,</span><span class="token number">4096</span><span class="token punctuation">,</span><span class="token number">8199</span><span class="token punctuation">,</span><span class="token number">7313</span><span class="token punctuation">,</span><span class="token number">3685</span><span class="token punctuation">,</span><span class="token number">211</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  temp<span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//temp临时存储第一个数据，方便用于与后面的数据进行相乘</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>  temp<span class="token operator">*</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前后数据进行相乘</span>   temp<span class="token operator">=</span><span class="token function">DivideZero</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去除数据某位的连续的"0"</span>   temp<span class="token operator">=</span>temp<span class="token operator">%</span><span class="token number">10000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//保留数据的后四位，不干扰求末尾0数据总数的同时缩小数据的大小</span>   <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>count<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出总计数值</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="ti-mu">题目②</span><a href="#ti-mu" class="header-anchor">#</a></h2><blockquote><p><strong>题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。  小明对数位中含有 2、0、1、9的数字很感兴趣，在 1 到 40 中这样的数包括 1、2、9、10 至 32、39和 40，共 28 个，他们的和是 574,平方和是 14362。注意，平方和是指将每个数分别平方后求和。请问，在 1 到 2019 中，所有这样的数的平方和是多少？</strong></p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><blockquote><p>这道题看起来有点类似于题目一，也是对数字位数的特殊判断，但是本题需要我们判断的条件有点多，我们采用另外一种思路来操作，即我们将数字转换成字符串类型，再采用范围for语句对字符串的每个字符进行变量，符合条件的我们就标记为true(1)，如果不符合条件我们就标记为false(0)。然后我们再对符合条件的数据进行平方和处理即可。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">long</span> <span class="token keyword">long</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化总平方和的变量sum，这里必须是long long 类型的，因为long long类型的数据范围是[-2^36,2^63-1],如果采用int类型，结果将溢出。</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">2019</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>  string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将数据i转换成字符串类型赋值给s</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> j<span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//采用范围for语句，对字符串s内的字符进行逐个遍历</span>      <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token string">'2'</span><span class="token operator">||</span>j<span class="token operator">==</span><span class="token string">'0'</span><span class="token operator">||</span>j<span class="token operator">==</span><span class="token string">'1'</span><span class="token operator">||</span>j<span class="token operator">==</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断是否有字符满足条件</span>        <span class="token punctuation">{</span>            sum<span class="token operator">+</span><span class="token operator">=</span><span class="token function">pow</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//若满足条件则直接计入总平方和的计数</span>           <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有一个字符满足条件了，说明该数字已经被判断好了，无需对剩余字符进行判断了，可以直接退出循环了</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>         <span class="token punctuation">}</span>   cout<span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出总的平方和</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="ti-mu">题目③</span><a href="#ti-mu" class="header-anchor">#</a></h2><blockquote><p><strong>题目描述本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。给定数列 1,1,1,3,5,9,17,⋯从第 4 项开始，每项都是前 3 项的和。求第 20190324 项的最后 4 位数字</strong></p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><blockquote><p>这道题的核心问题其实就对数据过大的处理，其实解决方案和第一题是一模一样的，题目需要你求最后四位数字，那我们就通过取余去保留最后四位数字，又因为根据加分的原则，最后四位数的相加和其它位上的数没有关联，所有我们直接通过取余去缩小数据的值，在不影响所求结果的情况下继续使数据以较小的值进行相加。这样就可以完美解决本题了</p></blockquote><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化最开始的前三位数</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">20190324</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//从第四位开始变量，遍历过程是a，b，c每次整体向后移一位</span>   <span class="token punctuation">{</span> temp<span class="token operator">=</span>c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//c代表最新的要更新的那个值，由于最新的那个值是前三位的值之和，平移的同时c的原数据不应被覆盖，所以我们拿一个临时变量temp用来存储c变量的原数据</span>     c<span class="token operator">=</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10000</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把最新的值赋值给c，整除10000是为了缩小数据的值，保留最后四位</span>     a<span class="token operator">=</span>b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将a数据向后平移一位，相当于把b的值赋给a</span>     b<span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//b数据也要向后平移一位，相当于要把c的原数据赋值给b</span>   <span class="token punctuation">}</span>   cout<span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//c是最新的那个所求值，输出c即可</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h2><blockquote><p><strong>这第一题和第二题其实都存在对数据位数上的条件判断，对此我们可以有两种处理方案。①：灵活运用整除和取余，来去除数据的位数或者取出指定位数，以此来解决位数的条件判断问题。②：我们可以将数字直接转换成字符串类型，然后应用范围for循环依次对字符串的各个位数进行条件判断。还有这两道题还有一个烦人的点就是数据溢出问题，无论是题目一的乘积还是题目二的求总平方和，它们的结果的数据都会很大，这时候呢，我们要么采用题目一的分而治方式：先将明显存在的0计数完，然后去除计数完的0，然后运用乘法原则，发现数据的有些位数其实根本影响不到本题的求解，于是直接利用取余运算，将冗余部分的位数去除。或者采用第二题的方式，直接将计数变量的类型定位 long long 类型以支持数据的正常输出。第三道题核心就是保留最后四位数以减少数据的溢出，原理其实和第一题差不多。</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯2020年省赛填空题(七段码)</title>
      <link href="/2023/08/21/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E5%B9%B4%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98-%E4%B8%83%E6%AE%B5%E7%A0%81/"/>
      <url>/2023/08/21/%E8%93%9D%E6%A1%A5%E6%9D%AF2020%E5%B9%B4%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98-%E4%B8%83%E6%AE%B5%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1><span id="lan-qiao-bei-qi-duan-ma-2020-nian-sheng-sai">蓝桥杯：七段码（2020 年省赛）</span><a href="#lan-qiao-bei-qi-duan-ma-2020-nian-sheng-sai" class="header-anchor">#</a></h1><p>小蓝要用七段码数码管来表示一种特殊的文字。</p><p><img src="https://img1.imgtp.com/2023/08/21/6lAHTPLZ.jpg"></p><p> 七段码上图给出了七段码数码管的一个图示，数码管中一共有7 段可以发光的二极管，<br> 分别标记为a, b, c, d, e, f, g。小蓝要选择一部分二极管（至少要有一个）发光来表达字符。<br> 在设计字符的表达时，要求所有发光的二极管是连成一片的。<br>例如：b 发光，其他二极管不发光可以用来表达一种字符。<br>例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上一行的方案可以用来表示不同的字符，尽管看上去比较相似。<br>例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。<br>例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。<br>请问，小蓝可以用七段码数码管表达多少种不同的字符？</p><h2><span id="wen-ti-fen-xi">问题分析</span><a href="#wen-ti-fen-xi" class="header-anchor">#</a></h2><h3><span id="wen-ti-jian-hua">问题简化</span><a href="#wen-ti-jian-hua" class="header-anchor">#</a></h3><blockquote><p><strong>根据题意所述，它需要我们求出能二极管能表达出的字符种类有多少个。那我们很容易就能想到这道题完全可以转换成求点到任意点的路径数量有多少的题目。但是由于a-&gt;b显示的图形和b-&gt;a显示出来的其实是一样的，所以最后的答案应该是路径的总数量/2</strong></p></blockquote><h3><span id="jie-jue-wen-ti">解决问题</span><a href="#jie-jue-wen-ti" class="header-anchor">#</a></h3><h4><span id="wen-ti-ti-chu">问题提出</span><a href="#wen-ti-ti-chu" class="header-anchor">#</a></h4><blockquote><p><strong>既然是搜索路径的题目，我们很容易就可以想到dfs深度优先遍历搜索算法，也就是选择任意一个点作为起始点，访问过的结点我们全部标记为True，随后不断进入子结点，直到碰到退出条件。dfs算法会对每个访问过的路径进行标记，标记过的结点则无法再次访问，这就导致了如果一个点到另外一个结点有两条路，dfs就只能优先遍历程序设置的那条路，另外一条路则不会被计算在内（如下演示图）</strong></p></blockquote><p><strong>正常的dfs遍历:</strong><br><img src="https://img1.imgtp.com/2023/08/21/DdRZJJeg.gif" alt="dfs"><br><strong>本题需要的遍历:</strong><br><img src="https://img1.imgtp.com/2023/08/21/bVTN4XtD.gif" alt="遍历"></p><h4><span id="jie-jue-fang-an">解决方案</span><a href="#jie-jue-fang-an" class="header-anchor">#</a></h4><blockquote><p>如上两个演示图，我们可以看到问题所在是dfs遇到返回条件返回的时候，遍历过的结点依旧被标记，这就导致了从B-&gt;D-E的路线，dfs其实是无法实现计算在内的。既然是标记结点的问题，那我们只要每一次遇到返回条件返回结点的时候把已经返回了的结点标记重置为False（未访问状态）不就可以完美解决本题了嘛，这就是基于DFS改编的<strong>回溯算法</strong>的雏形</p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><h2><span id="he-xin-dai-ma-jiang-jie">核心代码讲解</span><a href="#he-xin-dai-ma-jiang-jie" class="header-anchor">#</a></h2><pre class="line-numbers language-xml"><code class="language-xml">void Backtracking(int i, int visit[], int *count) {    for (int j = 0; j &lt; 7; j++) /*依次从a（0），b（1），c（2），d(3)，e(4)，f(5)，g(6)这七个二极管分别作为出发点进行遍历*/    {        if (graph[i][j] == 1 &amp;&amp; visit[j] == 0) //如果两个结点之间有连接且要访问的那个结点没有被访问过则满足条件        {            visit[j]=1;//提前标记我们要进入的那个结点已经被我们访问了            dfs(j, visit, count);//进入新结点，从新结点的基础上继续搜索路径            ( *count)++;//回退的时候进行计数            visit[j] = 0;//将已经回退的那个结点访问标记重置为0                            }                                    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>这里有一个细节要注意：我们的count初始化进来是值是1，因为存在一种情况：如果结点走到无路可走，程序其实是从if判断语句那里直接退出的，根本就没有进入if语句内部。也就是说当前的路径没有被计数进去，所以我们要在初始化count的时候就让它天然的就是以1为起步。</strong></p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">#include <iostream>using namespace std;int graph[7][7] = {//如果两个相邻的结点有连接，则标记为1，例如：(0,1)，0->1有连接，那么我们的graph[0][1]=1，同时1->0也是有连接的，那我们的graph[1][0]=1        {1, 1, 0, 0, 0, 1, 0},        {1, 1, 1, 0, 0, 0, 1},        {0, 1, 1, 1, 0, 0, 1},        {0, 0, 1, 1, 1, 0, 0},        {0, 0, 0, 1, 1, 1, 1},        {1, 0, 0, 0, 1, 1, 1},        {0, 1, 1, 0, 1, 1, 1}};void Backtracking(int i, int visit[], int *count) {    for (int j = 0; j < 7; j++) {        if (graph[i][j] == 1 && visit[j] == 0) {            visit[j]=1;            dfs(j, visit, count);            ( *count)++;            visit[j] = 0;                            }                                    }}int main() {    int count = 1;//将count变量用来计数    int visit[7] = {0};//初始化访问标记数组    Backtracking(0, visit, &count);//调用回溯函数    cout << count / 2 << endl;//输出种类数    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></iostream></code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start: 创建一个7×7的数组，用来存储结点的连接情况op=&gt;operation: 自定义函数Backtracking用来遍历结点op1=&gt;operation: 在Backtracking函数中改编DFS算法使之成为回溯算法，且符合条件后每次回退都进行路径数量的计数op2=&gt;operation: 因为我们要求的是路径所显示的图形，比如从a-&gt;b显示的图形和b-&gt;a显示出来的其实是一样的，所以最后我们要求的图形种类应该是总路径/2end=&gt;end: 输出总路径/2st-&gt;op-&gt;op1-&gt;op2-&gt;end</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的简单理解</title>
      <link href="/2023/08/20/%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
      <url>/2023/08/20/%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2><span id="tu">图</span><a href="#tu" class="header-anchor">#</a></h2><h3><span id="li-yong-shu-zu-gou-jian-tu">利用数组构建图</span><a href="#li-yong-shu-zu-gou-jian-tu" class="header-anchor">#</a></h3><h4><span id="wu-xiang-tu"><strong>无向图</strong></span><a href="#wu-xiang-tu" class="header-anchor">#</a></h4><pre class="line-numbers language-xml"><code class="language-xml">#include &lt;bits/stdc++.h>using  namespace  std;typedef char VertexType;typedef int EdgeType;#define MAXVER 100#define INFINITY 65532typedef struct{    VertexType vexs[MAXVER];    EdgeType arc[MAXVER][MAXVER];    int numNodes,numEdges;}MGraph;void CreatMGraph(MGraph *G){    int i,j,k,w;    cout&lt;&lt;"输入顶点数和边数:"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>    <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>G->numNodes>>G->numEdges;  //录入顶点和边数量的信息    cout&lt;&lt;"请输入顶点的具体的值"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>    <span class="token attr-name">for(i</span><span class="token attr-value"><span class="token punctuation">=</span>0;i&lt;G-</span><span class="token punctuation">></span></span>numNodes;i++)    {  cin>>G->vexs[i];    }    for(i=0;i<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes;i++)    {  for(j=1;j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes;j++)        {           G->arc[i][j]=INFINITY;        }      }    for(k=0;k<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes;k++)    {  cout&lt;&lt;"输入边(vi,vj)的下标i，j，以及权重w"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>        <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>i>>j>>w;        G->arc[i][j]=w;//输入权重值        G->arc[j][i]=w;    }//无向图的矩阵对称}int main(){    MGraph G1;//创建一个空的G1无向图变量     CreatMGraph(&amp;G1);//调用函数初始化G1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="li-yong-lian-biao-lai-gou-zao-tu">利用链表来构造图</span><a href="#li-yong-lian-biao-lai-gou-zao-tu" class="header-anchor">#</a></h3><h4><span id="wu-xiang-tu"><strong>无向图</strong></span><a href="#wu-xiang-tu" class="header-anchor">#</a></h4><pre class="line-numbers language-xml"><code class="language-xml">#include &lt;bits/stdc++.h>using  namespace  std;typedef char VertexType;typedef int EdgeType;#define MAXVEX 100#define INFINITY 65532typedef struct EdgeNode{ int adjvex;存储当前结点的位置    EdgeType weight;存储权值    struct EdgeNode *Next; 存储下一个指向的结点}EdgeNode; //构造出边表结点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码具象化：<br><img src="https://img1.imgtp.com/2023/08/20/PblUz2Ru.jpg" alt="构造出边表结点图"></p></blockquote><pre class="line-numbers language-xml"><code class="language-xml">typedef struct VertexNode{    VertexType data;//存储顶点的数值    EdgeNode *firstedge;//存储顶点指向的下一个结点}VertexNode,AdjList[MAXVEX];//构造出顶点列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码具象化：<br><img src="https://img1.imgtp.com/2023/08/20/oNvo9jJN.jpg" alt="构造出顶点列表图"></p></blockquote><pre class="line-numbers language-xml"><code class="language-xml">typedef struct{    AdjList adjList;    int numNodes,numEdges;}GraphAdjlist;void CreatMGraph(GraphAdjlist *G){    int i,j,k,w;    EdgeNode *e;//定义一个边表    cout&lt;&lt;"输入顶点数和边数:"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>    <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>G->numNodes>>G->numEdges;    for (int i=0; i<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes ; ++i) {      cin>>G->adjList[i].data;//初始化顶点表的data数值      G->adjList[i].firstedge=NULL;//初始化顶点表的firstedge的数值    }    for(k=0;k<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numEdges;k++)//    {        cout&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>"输入边（vi，vj）上的顶点序号";</span>        <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>i>>j;        e=(EdgeNode *)malloc(sizeof(EdgeNode));//申请边表类型的一个临时内存        e->adjvex=j;//把j输入到边表结点的adjvex上，表达当前j的位置        e->Next=G->adjList[i].firstedge;//采用头插法将位置为j的边表结点插入到头节点i对应的下一个结点。         G->adjList[i].firstedge=e;        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码具象化：<br><img src="https://img1.imgtp.com/2023/08/20/XTAqW8FZ.jpg" alt="头插法"></p></blockquote><p><strong>因为是无向图，所以正反两面都要配置，上面是i-&gt;j的配置,下面的代码是j-&gt;i的配置</strong></p><pre class="line-numbers language-xml"><code class="language-xml">        e=(EdgeNode *)malloc(sizeof(EdgeNode));        e->adjvex=i;        e->Next=G->adjList[j].firstedge;        G->adjList[j].firstedge=e;            }        free(e);//释放申请malloc的动态内存}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5><span id="wan-zheng-dai-ma">完整代码</span><a href="#wan-zheng-dai-ma" class="header-anchor">#</a></h5><pre class="line-numbers language-xml"><code class="language-xml">#include &lt;bits/stdc++.h>using  namespace  std;typedef char VertexType;typedef int EdgeType;#define MAXVEX 100#define INFINITY 65532typedef struct EdgeNode{ int adjvex;存储当前结点的位置    EdgeType weight;存储权值    struct EdgeNode *Next; 存储下一个指向的结点}EdgeNode; //构造出边表结点typedef struct VertexNode{    VertexType data;//存储顶点的数值    EdgeNode *firstedge;//存储顶点指向的下一个结点}VertexNode,AdjList[MAXVEX];//构造出顶点列表typedef struct{    AdjList adjList;    int numNodes,numEdges;}GraphAdjlist;void CreatMGraph(GraphAdjlist *G){    int i,j,k,w;    EdgeNode *e;//定义一个边表    cout&lt;&lt;"输入顶点数和边数:"&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>endl;</span>    <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>G->numNodes>>G->numEdges;    for (int i=0; i<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numNodes ; ++i) {      cin>>G->adjList[i].data;//初始化顶点表的data数值      G->adjList[i].firstedge=NULL;//初始化顶点表的firstedge的数值    }    for(k=0;k<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>G-</span><span class="token punctuation">></span></span>numEdges;k++)//    {        cout&lt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>"输入边（vi，vj）上的顶点序号";</span>        <span class="token attr-name">cin</span><span class="token punctuation">></span></span>>i>>j;        e=(EdgeNode *)malloc(sizeof(EdgeNode));//申请边表类型的一个临时内存        e->adjvex=j;//把j输入到边表结点的adjvex上，表达当前j的位置        e->Next=G->adjList[i].firstedge;//采用头插法将位置为j的边表结点插入到头节点i对应的下一个结点。          G->adjList[i].firstedge=e;        e=(EdgeNode *)malloc(sizeof(EdgeNode));        e->adjvex=i;        e->Next=G->adjList[j].firstedge;        G->adjList[j].firstedge=e;             }        free(e);//释放申请malloc的动态内存}int main(){GraphAdjlist *G1; CreatMGraph(G1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯2017年省赛填空题（统计出迷宫的人数）</title>
      <link href="/2023/08/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%88%E8%BF%B7%E5%AE%AB%EF%BC%89/"/>
      <url>/2023/08/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%88%E8%BF%B7%E5%AE%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2><span id="lan-qiao-bei-2017-nian-sheng-sai-tian-kong-ti-mi-gong">蓝桥杯2017年省赛填空题：迷宫</span><a href="#lan-qiao-bei-2017-nian-sheng-sai-tian-kong-ti-mi-gong" class="header-anchor">#</a></h2><blockquote><p>题目描述:<br>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。<br>X 星球的一处迷宫游乐场建在某个小山坡上。它是由 10×10 相互连通的小房间组成的。<br>房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：</p><ul><li>L 表示走到左边的房间，</li><li>R 表示走到右边的房间，</li><li>U 表示走到上坡方向的房间，</li><li>D 表示走到下坡方向的房间。</li></ul></blockquote><blockquote><p>X 星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！<br>开始的时候，直升机把 100 名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。<br>迷宫地图如下：<br>UDDLUULRUL<br>UURLLLRRRU<br>RRUURLDLRD<br>RUDDDDUUUU<br>URUDLLRRUU<br>DURLRLDLRL<br>ULLURLLRDU<br>RDLULLRDDD<br>UUDDUDUDLL<br>ULRDLUURRR<br>请你计算一下，最后，有多少玩家会走出迷宫，而不是在里边兜圈子？<br>如果你还没明白游戏规则，可以参看下面一个简化的 4x4 迷宫的解说图：<br><img src="https://img1.imgtp.com/2023/08/17/FEuRHtiB.jpg" alt="img"></p></blockquote><hr><h2><span id="zhi-shi-dian-chu-bei">知识点储备</span><a href="#zhi-shi-dian-chu-bei" class="header-anchor">#</a></h2><ul><li><strong>DFS深度优先遍历算法</strong></li><li><strong>树的前序遍历</strong></li><li><strong>递归</strong></li></ul><h3><span id="zhi-shi-dian-fu-xi">知识点复习</span><a href="#zhi-shi-dian-fu-xi" class="header-anchor">#</a></h3><h3><span id="shu-de-qian-xu-bian-li"><strong>树的前序遍历</strong>：</span><a href="#shu-de-qian-xu-bian-li" class="header-anchor">#</a></h3><h4><span id="kuai-su-gai-shu">快速概述</span><a href="#kuai-su-gai-shu" class="header-anchor">#</a></h4><blockquote><p>假如我们有如图所示的数据：<br><img src="https://img1.imgtp.com/2023/08/17/NWR3sFPX.jpg" alt="img"><br><strong>前置规定</strong>：我们规定把A作为根结点，且优先遍历左结点，直到左结点没有为止，然后再去走右结点，左右结点都遍历过了之后再回传到上一个父结点<br><strong>正式操作</strong>：我们从A结点开始出发，发现B和E结点两条路可以走，因为我们前置规定优先遍历左结点，所以走B结点，走到B结点发现左边没有结点可以走了，然后我们开始走B结点的右结点C，C结点之后按照同样的规定，我们依次遍历F、D 。走完D之后我们发现左右都没路了，我们开始回传到C结点、同样的F、D对结点于C来说是它的左右子结点， 我们已经遍历过了，于是C结点回传给B结点，同理B结点回传给A结点。对于A来说E结点还没遍历过，于是开始遍历E结点。E结点遍历之后按照同样的规则回传给A结点。至此，程序结束。</p></blockquote><hr><blockquote><p>文字描述看来很抽象，接下来我们直接放伪代码，来和文字结合理解一下。</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">struct Tree{  char data[2];//存储结点的名字    struct Tree *LeftNode;//存储结点左边的子节点    struct Tree *RightNode;//存储结点右边的子节点}*T;//创建树的结点T/*读入数据初始化结点T*/Void PreOrderTraverse(结点T){    if(T==NULL)  //如果该结点是空的，就执行return直接退出当前自定义函数         return;    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h4><blockquote><p>核心语句:</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>其实前序遍历的本质就是一个递归算法。前序遍历的第一句是 <strong>print(“%c”,T-&gt;data);</strong> 直接打印当前结点的名字，第二句<strong>PreOrderTraverse(T-&gt;LeftNode);</strong> 的意思是不断地进入左边的子结点，直到结点为空。同理第三句<strong>PreOrderTraverse(T-&gt;RightNode);<strong>的意思是承接第二句执行后的结点，去遍历这个结点的右边子节点。有就打印，没有（或者遍历过）就返回这个结点的父节点。</strong>结束标准：A结点的右边子节点全部遍历完毕，返回到A结点，则判定程序结束。</strong></p></blockquote><h3><span id="dfs-shen-du-you-xian-bian-li-suan-fa">DFS深度优先遍历算法</span><a href="#dfs-shen-du-you-xian-bian-li-suan-fa" class="header-anchor">#</a></h3><blockquote><p>了解了树的前序遍历之后呢，我们就来介绍我们的重头戏<strong>DFS深度优先遍历算法</strong></p><blockquote><p>在此之前，我想提出一个问题：假如你现在处于一个迷宫里面，里面有7个房间，你想要去碰碰运气找遍所有房间，那你该怎么做？</p></blockquote><blockquote><p>我觉得大部分人的第一反应就是从某个房间出发，然后不断一个一个找过去，已经走过的，我们就标记一下，直到又回到了出发的那个房间为止。</p><blockquote><p><strong>这种方式就是DFS深度优先遍历算法的雏形</strong></p></blockquote></blockquote></blockquote><h4><span id="kuai-su-gai-shu">快速概述</span><a href="#kuai-su-gai-shu" class="header-anchor">#</a></h4><blockquote><p>假如我们有如下的数据<br><img src="https://img1.imgtp.com/2023/08/17/v5n6Efb3.jpg" alt="img"><br><strong>前置规定</strong>：我们可以随机选择一个结点作为根结点，且优先遍历左结点，（<strong>同时每走一个结点，我们用变量 visit 标记一下，表明我们走过这个结点了。</strong>）</p><blockquote><p><strong>回退结点的规则</strong>：<strong>若结点被visit标记了或者左右结点都不存在</strong></p></blockquote></blockquote><blockquote><p><strong>正式操作</strong>：我们从A结点开始出发，发现B和E结点两条路可以走，因为我们前置规定优先遍历左结点，所以走B结点，B结点左边是C结点，于是我们来到了C结点，同理C结点的的左边是F，F的左节点是G，G的左节点是E，E的左节点是A结点，但是A是我们走过的结点，已经用visit标记了，于是我们从A返回到E结点，继续执行E结点剩余的程序，显然E结点没有右子结点了，于是我们退回G结点，按照同样的规律，最后我们将退回结点到A结点，至此，程序结束。</p></blockquote><blockquote><blockquote><p><strong>看到这里，有没有发现DFS深度优先遍历算法其实就是前序遍历算法的变式呀，只不过DFS深度遍历算法增加了变量visit用来标记已经变量过的结点，以此来提早退回遍历过的结点。</strong></p></blockquote></blockquote><h4><span id="dai-ma-shi-xian">代码实现</span><a href="#dai-ma-shi-xian" class="header-anchor">#</a></h4><pre class="line-numbers language-c++"><code class="language-c++">struct Tree{  char data[2];//存储结点的名字   int vist=0;//规定visit=0还没有被遍历，visit=1，则已经被遍历    struct Tree *LeftNode;//存储结点左边的子节点    struct Tree *RightNode;//存储结点右边的子节点}*T;//创建树的结点T/*读入数据初始化结点T*/Void PreOrderTraverse(结点T){    if(T==NULL)  //如果该结点是空的，就执行return直接退出当前自定义函数         return;     if (visit==1)//如果当前结点已经被访问过了，那么直接退出当前自定义函数，         return ;                                        // 返回上一个结点        T->visit=1; //当前结点已经被遍历    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5><span id="xi-jie-jie-shi">细节解释</span><a href="#xi-jie-jie-shi" class="header-anchor">#</a></h5><p><img src="https://img1.imgtp.com/2023/08/17/v5n6Efb3.jpg" alt="img"></p><blockquote><p>假如我们已经从E执行到了A结点，此时我们发现A是已经被visit标记了的,源代码对应：</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">if (visit==1)//如果当前结点已经被访问过了，那么直接退出当前自定义函数，    return;                      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><blockquote><p>此时我们从A回退到E结点来执行E结点的剩余代码：<br><strong>PreOrderTraverse(T-&gt;RightNode);//进入结点右边的子节点</strong><br><strong>因为是回退结点，而不是对该结点的重头开始执行，所以从A结点回退到E结点的时候，对于E结点来说：   PreOrderTraverse(T-&gt;LeftNode);已经执行完毕，所以我们只要执行它的下一行PreOrderTraverse(T-&gt;RightNode);即可。</strong></p></blockquote><hr><h2><span id="ti-mu-jiang-jie">题目讲解</span><a href="#ti-mu-jiang-jie" class="header-anchor">#</a></h2><blockquote><p>有了上面的知识储备之后， 我们回归题目本身</p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-xml"><code class="language-xml">//#include &lt;bits/stdc++.h>#include<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iostream</span><span class="token punctuation">></span></span>#include<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string.h</span><span class="token punctuation">></span></span>using  namespace  std;char Maps[10][10]={        'U','D','D','L','U','U','L','R','U','L',        'U','U','R','L','L','L','R','R','R','U',        'R','R','U','U','R','L','D','L','R','D',        'R','U','D','D','D','D','U','U','U','U',        'U','R','U','D','L','L','R','R','U','U',        'D','U','R','L','R','L','D','L','R','L',        'U','L','L','U','R','L','L','R','D','U',        'R','D','L','U','L','L','R','D','D','D',        'U','U','D','D','U','D','U','D','L','L',        'U','L','R','D','L','U','U','R','R','R'};//初始化地图int visit[10][10];//创建visit变量void dfs(int i,int j,int*count) {    if (i&lt;0||i>9||j&lt;0||j>9)    {        (*count)++;//人数+1。count我们传入的是指针，这样可以实现自定义外函数的count也在同步变化        return ;//过程中没有一次碰到走过的路，并且最后来到了地图边缘，此时我们可以判定出迷宫了    }   else    {        if(visit[i][j])        {  return ;        }//假如走的时候发现这条路是走过的，说明是鬼打墙。就不需要继续走下去了，可以直接提早结束            visit[i][j]=1;//走过的块我们标记为1说明已经走过了            if (Maps[i][j]=='U')                dfs(i-1,j,count);//当前方块是U的话就行数减一,向上走            else if (Maps[i][j]=='D')//当前方块是D的话行数加一，向下走                dfs(i+1,j,count);            else if(Maps[i][j]=='L')//当前方块是L的话列数减一，向左走                dfs(i,j-1,count);            else if (Maps[i][j]=='R')//当前方块是L的话列数加一，向右走                dfs(i,j+1,count);    }}int main(){ int count=0;//初始化能够走出迷宫的人数    for(int i=0;i&lt;10;i++)    {        for(int j=0;j&lt;10;j++)        {            memset(visit, 0, sizeof(visit));//memset是用来将visit里面的数组的值全部初始化为0            dfs(i,j,&amp;count);        }//通过两个for循环嵌套去逐个对每个方格进行dfs遍历搜寻判断    } cout&lt;&lt;count&lt;&lt;endl;//输出count即可}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路借鉴：<a href="https://blog.csdn.net/SakuraZhangrx/article/details/106922392">https://blog.csdn.net/SakuraZhangrx/article/details/106922392</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start:  用数组初始化10×10的地图op=&gt;operation:  命名一个自定义函数为dfs()，其中dfs中正常能够出地图的，我们采用count变量+1来统计op1=&gt;operation: 主程序中我们使用嵌套for循环依次对地图的每一块依次变量e=&gt;end: 输出countst-&gt;op-&gt;op1-&gt;e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构笔记(一)：算法复杂度（基础篇）</title>
      <link href="/2023/08/15/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC(%E5%9F%BA%E7%A1%80%E7%AF%87)/"/>
      <url>/2023/08/15/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC(%E5%9F%BA%E7%A1%80%E7%AF%87)/</url>
      
        <content type="html"><![CDATA[<h2><span id="suan-fa-fu-za-du-fen-xi-jian-yao-gai-gua">算法复杂度分析简要概括</span><a href="#suan-fa-fu-za-du-fen-xi-jian-yao-gai-gua" class="header-anchor">#</a></h2><p><strong>算法复杂度</strong></p><ul><li><strong>时间复杂度</strong></li><li><strong>空间复杂度</strong></li></ul><hr><blockquote><p>时间复杂度的简单理解：进行算法分析时，我们假设每行的每次执行时间是t，n是某个循环的中止值。随后我们统计下所有行的代码执行次数，记作f(n)，那么我们整个的程序的总的执行时间T为:f(n)×t。根据T函数我们可以看出T与f(n)成正比。此时我们就可以根据f(n)的函数增长率去估算时间复杂度，<strong>这里我们需要注意的是,我们只关注函数的增长率，而不关注n究竟是多大。</strong></p></blockquote><h2><span id="tui-dao-fang-fa-jie-shao">推导方法介绍</span><a href="#tui-dao-fang-fa-jie-shao" class="header-anchor">#</a></h2><h3><span id="tui-dao-liu-cheng">推导流程</span><a href="#tui-dao-liu-cheng" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><p><strong>核心：只关注推导出来的函数的最高阶项的阶数</strong></p><h3><span id="ju-ge-li-zi">举个栗子</span><a href="#ju-ge-li-zi" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行1次</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//执行n+1次</span><span class="token punctuation">{</span> count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行n次</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>根据注释可推出总次数的函数式f(n)=1+n+1+n=2n+2</p></blockquote><p><strong>化简原则:</strong></p><ul><li><strong>①函数如果是一个常数，不管多大，全用1代替，记作O(1)</strong></li><li><strong>②函数只保留最高阶项，若最高阶项的系数是常数，则统一用1代替，否则保留系数</strong></li></ul><blockquote><p>本题根据化简原则②可以将f(n)=2n+2，记作f(n)=n,即O(n),这就是我们这段程序的时间复杂度</p></blockquote><h3><span id="yi-wen">疑问</span><a href="#yi-wen" class="header-anchor">#</a></h3><blockquote><p>Q1:刚学的时候，关于这道例子我是有一个问题的，那就是n明明在一开始的时候就定义了n=100。那n不应该是一个常数吗？我的函数式不应该写成1+100+1+100=202吗？时间复杂度应该是O(1)而不是O(n)呀</p></blockquote><hr><blockquote><p>A1：我认为时间复杂度的理解应该是基于过程而言的，而不是基于结果的。基于结果，整个n肯定是一个有结果的值，我们可以看作它是一个基于常数时间复杂度的算法。但是当我们谈论时间复杂度时，我们通常会假设 n 是一个变量，它可以取任意值。这样我们就可以分析算法的运行时间随着输入数据规模的增长而增长的速度。</p><p>回到上面的问题，f(n)=2n+2,我们说n=100的时候，我们从结果的角度看，的确它可以叫做O(1)的时间复杂度，但是n是可以变化的，n可以是1，2，3……10000等等。也就是说我们是不只研究单单n=100这一个例子。我们研究的是一整个关于f(n)函数的增长变化情况的全局，本题的例子中这个f(n)的变化明显是类似于线性的变化，于是我们根据化简原则，可以得出时间复杂度是O(n),而不是O(1)<br><img src="https://img1.imgtp.com/2023/08/16/2LRqrNWv.png" alt="img"></p></blockquote><h3><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h3><blockquote><p><strong>算法的复杂度是基于过程的而非单一的结果,根据循环的规律去写出次数对应的函数是关键，因为我们研究的是函数的整体变化速率。最后，根据化简原则，我们将函数化简之后得到的表达式就是我们需要的时间复杂度O()</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start: 列出各行代码的执行次数op=&gt;operation: 统计总次数并且写成函数式子op1=&gt;operation: 对函数式子进行化简处理e=&gt;end: 分析结果st-&gt;op-&gt;op1-&gt;e</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2023/08/14/%E5%89%8D%E8%A8%80/"/>
      <url>/2023/08/14/%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>说实话，这是我第一次想着搭建一个个人博客来创作，事情的起因是前天学校老师给了我一套蓝桥杯的算法资料，那套资料对于算法的分类写的非常清晰，一目了然。于是我当时二话不说就写了一下午。不得不说，如果算法如果不难的话还是很有趣的<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。哈哈哈。那种感觉就像成功就在你眼前，但是你一抓他就往前跑。不断刺激你去抓到他。这种感觉是又爱又恨。那天写了几节之后，我开始问我自己，学习这些算法，如果我只是单单的像流水线一样过了一遍，真的有效吗？有过之前经历过无数次现实毒打的经历的经验之后，我明确告诉我自己，这是不可能的，学习的本质应该是不断的重复，以来对抗遗忘。所以顺其自然的我就想着搭建一个个人博客，来主要作为记录我个人的笔记平台，用来总结我写过的每一道算法题，以及背后对原理的思考。</p><p>比起传统的纸质笔记本，我认为电子化笔记的可以不受地点和时间的制约，这是我选择它的一大原因。同时呢，如果有能力的话，我也想分享高中的信息技术的内容。因为曾经我最迷茫的时候，是很多拥有公众号的技术老师以及博主分享了很多珍贵的资料，让我在黑暗中能够看见光亮。高中信息技术这门课改革之后加入了python以及数据结构。难度直线飙升，这对本就缺少资源的普通高中的学生更是雪上加霜。我深深的体会过这一点，所以我也想分享这些内容，发一点光，帮助曾经像我一样迷茫的同学们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
