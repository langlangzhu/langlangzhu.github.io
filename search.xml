<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>蓝桥杯2017年省赛填空题（统计出迷宫的人数）</title>
      <link href="/2023/08/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%88%E8%BF%B7%E5%AE%AB%EF%BC%89/"/>
      <url>/2023/08/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B%E5%A1%AB%E7%A9%BA%E9%A2%98%EF%BC%88%E8%BF%B7%E5%AE%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2><span id="lan-qiao-bei-2017-nian-sheng-sai-tian-kong-ti-mi-gong">蓝桥杯2017年省赛填空题：迷宫</span><a href="#lan-qiao-bei-2017-nian-sheng-sai-tian-kong-ti-mi-gong" class="header-anchor">#</a></h2><blockquote><p>题目描述:<br>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。<br>X 星球的一处迷宫游乐场建在某个小山坡上。它是由 10×10 相互连通的小房间组成的。<br>房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：</p><ul><li>L 表示走到左边的房间，</li><li>R 表示走到右边的房间，</li><li>U 表示走到上坡方向的房间，</li><li>D 表示走到下坡方向的房间。</li></ul></blockquote><blockquote><p>X 星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！<br>开始的时候，直升机把 100 名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。<br>迷宫地图如下：<br>UDDLUULRUL<br>UURLLLRRRU<br>RRUURLDLRD<br>RUDDDDUUUU<br>URUDLLRRUU<br>DURLRLDLRL<br>ULLURLLRDU<br>RDLULLRDDD<br>UUDDUDUDLL<br>ULRDLUURRR<br>请你计算一下，最后，有多少玩家会走出迷宫，而不是在里边兜圈子？<br>如果你还没明白游戏规则，可以参看下面一个简化的 4x4 迷宫的解说图：<br><img src="https://img1.imgtp.com/2023/08/17/FEuRHtiB.jpg" alt="img"></p></blockquote><hr><h2><span id="zhi-shi-dian-chu-bei">知识点储备</span><a href="#zhi-shi-dian-chu-bei" class="header-anchor">#</a></h2><ul><li><strong>DFS深度优先遍历算法</strong></li><li><strong>树的前序遍历</strong></li><li><strong>递归</strong></li></ul><h3><span id="zhi-shi-dian-fu-xi">知识点复习</span><a href="#zhi-shi-dian-fu-xi" class="header-anchor">#</a></h3><h3><span id="shu-de-qian-xu-bian-li"><strong>树的前序遍历</strong>：</span><a href="#shu-de-qian-xu-bian-li" class="header-anchor">#</a></h3><h4><span id="kuai-su-gai-shu">快速概述</span><a href="#kuai-su-gai-shu" class="header-anchor">#</a></h4><blockquote><p>假如我们有如图所示的数据：<br><img src="https://img1.imgtp.com/2023/08/17/NWR3sFPX.jpg" alt="img"><br><strong>前置规定</strong>：我们规定把A作为根结点，且优先遍历左结点，直到左结点没有为止，然后再去走右结点，左右结点都遍历过了之后再回传到上一个父结点<br><strong>正式操作</strong>：我们从A结点开始出发，发现B和E结点两条路可以走，因为我们前置规定优先遍历左结点，所以走B结点，走到B结点发现左边没有结点可以走了，然后我们开始走B结点的右结点C，C结点之后按照同样的规定，我们依次遍历F、D 。走完D之后我们发现左右都没路了，我们开始回传到C结点、同样的F、D对结点于C来说是它的左右子结点， 我们已经遍历过了，于是C结点回传给B结点，同理B结点回传给A结点。对于A来说E结点还没遍历过，于是开始遍历E结点。E结点遍历之后按照同样的规则回传给A结点。至此，程序结束。</p></blockquote><hr><blockquote><p>文字描述看来很抽象，接下来我们直接放伪代码，来和文字结合理解一下。</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">struct Tree{  char data[2];//存储结点的名字    struct Tree *LeftNode;//存储结点左边的子节点    struct Tree *RightNode;//存储结点右边的子节点}*T;//创建树的结点T/*读入数据初始化结点T*/Void PreOrderTraverse(结点T){    if(T==NULL)  //如果该结点是空的，就执行return直接退出当前自定义函数         return;    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h4><blockquote><p>核心语句:</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>其实前序遍历的本质就是一个递归算法。前序遍历的第一句是 <strong>print(“%c”,T-&gt;data);</strong> 直接打印当前结点的名字，第二句<strong>PreOrderTraverse(T-&gt;LeftNode);</strong> 的意思是不断地进入左边的子结点，直到结点为空。同理第三句<strong>PreOrderTraverse(T-&gt;RightNode);<strong>的意思是承接第二句执行后的结点，去遍历这个结点的右边子节点。有就打印，没有（或者遍历过）就返回这个结点的父节点。</strong>结束标准：A结点的右边子节点全部遍历完毕，返回到A结点，则判定程序结束。</strong></p></blockquote><h3><span id="dfs-shen-du-you-xian-bian-li-suan-fa">DFS深度优先遍历算法</span><a href="#dfs-shen-du-you-xian-bian-li-suan-fa" class="header-anchor">#</a></h3><blockquote><p>了解了树的前序遍历之后呢，我们就来介绍我们的重头戏<strong>DFS深度优先遍历算法</strong></p><blockquote><p>在此之前，我想提出一个问题：假如你现在处于一个迷宫里面，里面有7个房间，你想要去碰碰运气找遍所有房间，那你该怎么做？</p></blockquote><blockquote><p>我觉得大部分人的第一反应就是从某个房间出发，然后不断一个一个找过去，已经走过的，我们就标记一下，直到又回到了出发的那个房间为止。</p><blockquote><p><strong>这种方式就是DFS深度优先遍历算法的雏形</strong></p></blockquote></blockquote></blockquote><h4><span id="kuai-su-gai-shu">快速概述</span><a href="#kuai-su-gai-shu" class="header-anchor">#</a></h4><blockquote><p>假如我们有如下的数据<br><img src="https://img1.imgtp.com/2023/08/17/v5n6Efb3.jpg" alt="img"><br><strong>前置规定</strong>：我们可以随机选择一个结点作为根结点，且优先遍历左结点，（<strong>同时每走一个结点，我们用变量 visit 标记一下，表明我们走过这个结点了。</strong>）</p><blockquote><p><strong>回退结点的规则</strong>：<strong>若结点被visit标记了或者左右结点都不存在</strong></p></blockquote></blockquote><blockquote><p><strong>正式操作</strong>：我们从A结点开始出发，发现B和E结点两条路可以走，因为我们前置规定优先遍历左结点，所以走B结点，B结点左边是C结点，于是我们来到了C结点，同理C结点的的左边是F，F的左节点是G，G的左节点是E，E的左节点是A结点，但是A是我们走过的结点，已经用visit标记了，于是我们从A返回到E结点，继续执行E结点剩余的程序，显然E结点没有右子结点了，于是我们退回G结点，按照同样的规律，最后我们将退回结点到A结点，至此，程序结束。</p></blockquote><blockquote><blockquote><p><strong>看到这里，有没有发现DFS深度优先遍历算法其实就是前序遍历算法的变式呀，只不过DFS深度遍历算法增加了变量visit用来标记已经变量过的结点，以此来提早退回遍历过的结点。</strong></p></blockquote></blockquote><h4><span id="dai-ma-shi-xian">代码实现</span><a href="#dai-ma-shi-xian" class="header-anchor">#</a></h4><pre class="line-numbers language-c++"><code class="language-c++">struct Tree{  char data[2];//存储结点的名字   int vist=0;//规定visit=0还没有被遍历，visit=1，则已经被遍历    struct Tree *LeftNode;//存储结点左边的子节点    struct Tree *RightNode;//存储结点右边的子节点}*T;//创建树的结点T/*读入数据初始化结点T*/Void PreOrderTraverse(结点T){    if(T==NULL)  //如果该结点是空的，就执行return直接退出当前自定义函数         return;     if (visit==1)//如果当前结点已经被访问过了，那么直接退出当前自定义函数，         return ;                                        // 返回上一个结点        T->visit=1; //当前结点已经被遍历    print("%c",T->data);//打印当前结点的名字    PreOrderTraverse(T->LeftNode);//进入结点左边的子节点    PreOrderTraverse(T->RightNode);//进入结点右边的子节点}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5><span id="xi-jie-jie-shi">细节解释</span><a href="#xi-jie-jie-shi" class="header-anchor">#</a></h5><p><img src="https://img1.imgtp.com/2023/08/17/v5n6Efb3.jpg" alt="img"></p><blockquote><p>假如我们已经从E执行到了A结点，此时我们发现A是已经被visit标记了的,源代码对应：</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">if (visit==1)//如果当前结点已经被访问过了，那么直接退出当前自定义函数，    return;                      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><blockquote><p>此时我们从A回退到E结点来执行E结点的剩余代码：<br><strong>PreOrderTraverse(T-&gt;RightNode);//进入结点右边的子节点</strong><br><strong>因为是回退结点，而不是对该结点的重头开始执行，所以从A结点回退到E结点的时候，对于E结点来说：   PreOrderTraverse(T-&gt;LeftNode);已经执行完毕，所以我们只要执行它的下一行PreOrderTraverse(T-&gt;RightNode);即可。</strong></p></blockquote><hr><h2><span id="ti-mu-jiang-jie">题目讲解</span><a href="#ti-mu-jiang-jie" class="header-anchor">#</a></h2><blockquote><p>有了上面的知识储备之后， 我们回归题目本身</p></blockquote><h3><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><h3><span id="yuan-dai-ma">源代码</span><a href="#yuan-dai-ma" class="header-anchor">#</a></h3><pre class="line-numbers language-xml"><code class="language-xml">//#include &lt;bits/stdc++.h>#include<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iostream</span><span class="token punctuation">></span></span>#include<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>string.h</span><span class="token punctuation">></span></span>using  namespace  std;char Maps[10][10]={        'U','D','D','L','U','U','L','R','U','L',        'U','U','R','L','L','L','R','R','R','U',        'R','R','U','U','R','L','D','L','R','D',        'R','U','D','D','D','D','U','U','U','U',        'U','R','U','D','L','L','R','R','U','U',        'D','U','R','L','R','L','D','L','R','L',        'U','L','L','U','R','L','L','R','D','U',        'R','D','L','U','L','L','R','D','D','D',        'U','U','D','D','U','D','U','D','L','L',        'U','L','R','D','L','U','U','R','R','R'};//初始化地图int visit[10][10];//创建visit变量void dfs(int i,int j,int*count) {    if (i&lt;0||i>9||j&lt;0||j>9)    {        (*count)++;//人数+1。count我们传入的是指针，这样可以实现自定义外函数的count也在同步变化        return ;//过程中没有一次碰到走过的路，并且最后来到了地图边缘，此时我们可以判定出迷宫了    }   else    {        if(visit[i][j])        {  return ;        }//假如走的时候发现这条路是走过的，说明是鬼打墙。就不需要继续走下去了，可以直接提早结束            visit[i][j]=1;//走过的块我们标记为1说明已经走过了            if (Maps[i][j]=='U')                dfs(i-1,j,count);//当前方块是U的话就行数减一,向上走            else if (Maps[i][j]=='D')//当前方块是D的话行数加一，向下走                dfs(i+1,j,count);            else if(Maps[i][j]=='L')//当前方块是L的话列数减一，向左走                dfs(i,j-1,count);            else if (Maps[i][j]=='R')//当前方块是L的话列数加一，向右走                dfs(i,j+1,count);    }}int main(){ int count=0;//初始化能够走出迷宫的人数    for(int i=0;i&lt;10;i++)    {        for(int j=0;j&lt;10;j++)        {            memset(visit, 0, sizeof(visit));//memset是用来将visit里面的数组的值全部初始化为0            dfs(i,j,&amp;count);        }//通过两个for循环嵌套去逐个对每个方格进行dfs遍历搜寻判断    } cout&lt;&lt;count&lt;&lt;endl;//输出count即可}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路借鉴：<a href="https://blog.csdn.net/SakuraZhangrx/article/details/106922392">https://blog.csdn.net/SakuraZhangrx/article/details/106922392</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start:  用数组初始化10×10的地图op=&gt;operation:  命名一个自定义函数为dfs()，其中dfs中正常能够出地图的，我们采用count变量+1来统计op1=&gt;operation: 主程序中我们使用嵌套for循环依次对地图的每一块依次变量e=&gt;end: 输出countst-&gt;op-&gt;op1-&gt;e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构笔记(一)：算法复杂度（基础篇）</title>
      <link href="/2023/08/15/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC(%E5%9F%BA%E7%A1%80%E7%AF%87)/"/>
      <url>/2023/08/15/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC(%E5%9F%BA%E7%A1%80%E7%AF%87)/</url>
      
        <content type="html"><![CDATA[<h2><span id="suan-fa-fu-za-du-fen-xi-jian-yao-gai-gua">算法复杂度分析简要概括</span><a href="#suan-fa-fu-za-du-fen-xi-jian-yao-gai-gua" class="header-anchor">#</a></h2><p><strong>算法复杂度</strong></p><ul><li><strong>时间复杂度</strong></li><li><strong>空间复杂度</strong></li></ul><hr><blockquote><p>时间复杂度的简单理解：进行算法分析时，我们假设每行的每次执行时间是t，n是某个循环的中止值。随后我们统计下所有行的代码执行次数，记作f(n)，那么我们整个的程序的总的执行时间T为:f(n)×t。根据T函数我们可以看出T与f(n)成正比。此时我们就可以根据f(n)的函数增长率去估算时间复杂度，<strong>这里我们需要注意的是,我们只关注函数的增长率，而不关注n究竟是多大。</strong></p></blockquote><h2><span id="tui-dao-fang-fa-jie-shao">推导方法介绍</span><a href="#tui-dao-fang-fa-jie-shao" class="header-anchor">#</a></h2><h3><span id="tui-dao-liu-cheng">推导流程</span><a href="#tui-dao-liu-cheng" class="header-anchor">#</a></h3><div id="flowchart-0" class="flow-chart"></div><p><strong>核心：只关注推导出来的函数的最高阶项的阶数</strong></p><h3><span id="ju-ge-li-zi">举个栗子</span><a href="#ju-ge-li-zi" class="header-anchor">#</a></h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行1次</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//执行n+1次</span><span class="token punctuation">{</span> count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行n次</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>根据注释可推出总次数的函数式f(n)=1+n+1+n=2n+2</p></blockquote><p><strong>化简原则:</strong></p><ul><li><strong>①函数如果是一个常数，不管多大，全用1代替，记作O(1)</strong></li><li><strong>②函数只保留最高阶项，若最高阶项的系数是常数，则统一用1代替，否则保留系数</strong></li></ul><blockquote><p>本题根据化简原则②可以将f(n)=2n+2，记作f(n)=n,即O(n),这就是我们这段程序的时间复杂度</p></blockquote><h3><span id="yi-wen">疑问</span><a href="#yi-wen" class="header-anchor">#</a></h3><blockquote><p>Q1:刚学的时候，关于这道例子我是有一个问题的，那就是n明明在一开始的时候就定义了n=100。那n不应该是一个常数吗？我的函数式不应该写成1+100+1+100=202吗？时间复杂度应该是O(1)而不是O(n)呀</p></blockquote><hr><blockquote><p>A1：我认为时间复杂度的理解应该是基于过程而言的，而不是基于结果的。基于结果，整个n肯定是一个有结果的值，我们可以看作它是一个基于常数时间复杂度的算法。但是当我们谈论时间复杂度时，我们通常会假设 n 是一个变量，它可以取任意值。这样我们就可以分析算法的运行时间随着输入数据规模的增长而增长的速度。</p><p>回到上面的问题，f(n)=2n+2,我们说n=100的时候，我们从结果的角度看，的确它可以叫做O(1)的时间复杂度，但是n是可以变化的，n可以是1，2，3……10000等等。也就是说我们是不只研究单单n=100这一个例子。我们研究的是一整个关于f(n)函数的增长变化情况的全局，本题的例子中这个f(n)的变化明显是类似于线性的变化，于是我们根据化简原则，可以得出时间复杂度是O(n),而不是O(1)<br><img src="https://img1.imgtp.com/2023/08/16/2LRqrNWv.png" alt="img"></p></blockquote><h3><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h3><blockquote><p><strong>算法的复杂度是基于过程的而非单一的结果,根据循环的规律去写出次数对应的函数是关键，因为我们研究的是函数的整体变化速率。最后，根据化简原则，我们将函数化简之后得到的表达式就是我们需要的时间复杂度O()</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start: 列出各行代码的执行次数op=&gt;operation: 统计总次数并且写成函数式子op1=&gt;operation: 对函数式子进行化简处理e=&gt;end: 分析结果st-&gt;op-&gt;op1-&gt;e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2023/08/14/%E5%89%8D%E8%A8%80/"/>
      <url>/2023/08/14/%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>说实话，这是我第一次想着搭建一个个人博客来创作，事情的起因是前天学校老师给了我一套蓝桥杯的算法资料，那套资料对于算法的分类写的非常清晰，一目了然。于是我当时二话不说就写了一下午。不得不说，如果算法如果不难的话还是很有趣的<span class="github-emoji"><span>🐶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f436.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。哈哈哈。那种感觉就像成功就在你眼前，但是你一抓他就往前跑。不断刺激你去抓到他。这种感觉是又爱又恨。那天写了几节之后，我开始问我自己，学习这些算法，如果我只是单单的像流水线一样过了一遍，真的有效吗？有过之前经历过无数次现实毒打的经历的经验之后，我明确告诉我自己，这是不可能的，学习的本质应该是不断的重复，以来对抗遗忘。所以顺其自然的我就想着搭建一个个人博客，来主要作为记录我个人的笔记平台，用来总结我写过的每一道算法题，以及背后对原理的思考。</p><p>比起传统的纸质笔记本，我认为电子化笔记的可以不受地点和时间的制约，这是我选择它的一大原因。同时呢，如果有能力的话，我也想分享高中的信息技术的内容。因为曾经我最迷茫的时候，是很多拥有公众号的技术老师以及博主分享了很多珍贵的资料，让我在黑暗中能够看见光亮。高中信息技术这门课改革之后加入了python以及数据结构。难度直线飙升，这对本就缺少资源的普通高中的学生更是雪上加霜。我深深的体会过这一点，所以我也想分享这些内容，发一点光，帮助曾经像我一样迷茫的同学们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
